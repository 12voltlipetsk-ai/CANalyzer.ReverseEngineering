using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using CANalyzer.Core.Models;

namespace CANalyzer.Core.Parsers
{
    public class LogParser
    {
        public static List<CANMessage> Parse(string filePath, LogFormat format)
        {
            return format switch
            {
                LogFormat.CSV => ParseCSV(filePath) ?? new List<CANMessage>(),
                LogFormat.ASC => ParseASC(filePath) ?? new List<CANMessage>(),
                LogFormat.BLF => ParseBLF(filePath) ?? new List<CANMessage>(),
                _ => new List<CANMessage>()
            };
        }

        public static List<CANMessage> ParseCSV(string filePath)
        {
            var messages = new List<CANMessage>();
            
            try
            {
                Console.WriteLine($"Парсинг CSV файла: {filePath}");
                
                using var reader = new StreamReader(filePath);
                string? line;
                bool headerProcessed = false;
                Dictionary<string, int> headerIndices = new Dictionary<string, int>();
                bool isPeakConverterFormat = false;

                while ((line = reader.ReadLine()) != null)
                {
                    // Пропускаем служебные строки в начале файла
                    if (line.StartsWith("$STARTTIME") || 
                        line.StartsWith("Start time") || 
                        line.StartsWith("C:\\") || 
                        line.Contains("Generated by") || 
                        line.Contains("Data imported") || 
                        line.StartsWith("---") || 
                        line.StartsWith("Glossary") || 
                        line.StartsWith("    ") || 
                        string.IsNullOrWhiteSpace(line))
                    {
                        if (line.Contains("PEAK-Converter"))
                        {
                            isPeakConverterFormat = true;
                            Console.WriteLine("Обнаружен формат PEAK-Converter");
                        }
                        continue;
                    }

                    var parts = line.Split(',');

                    // Обработка заголовка
                    if (!headerProcessed)
                    {
                        if (parts.Length > 5)
                        {
                            for (int i = 0; i < parts.Length; i++)
                            {
                                string header = parts[i].Trim().ToLower();
                                
                                if (header.Contains("time"))
                                    headerIndices["time"] = i;
                                else if (header.Contains("id") || header.Contains("pid"))
                                    headerIndices["id"] = i;
                                else if (header == "length" || header.Contains("dlc"))
                                    headerIndices["dlc"] = i;
                                else if (header == "bus" || header.Contains("bus") || header.Contains("channel"))
                                    headerIndices["channel"] = i;
                                else if (header.StartsWith("d") && (header.Length == 2 || header.Length == 3))
                                {
                                    // D0, D1, ..., D63
                                    headerIndices[header.ToLower()] = i;
                                }
                            }
                            
                            Console.WriteLine($"Найдены заголовки: {string.Join(", ", headerIndices.Keys)}");
                            
                            if (headerIndices.ContainsKey("time") && headerIndices.ContainsKey("id"))
                            {
                                headerProcessed = true;
                                continue;
                            }
                        }
                    }

                    // Пропускаем строки без данных
                    if (!headerProcessed || parts.Length < 3)
                        continue;

                    try
                    {
                        CANMessage? message = null;
                        
                        if (isPeakConverterFormat)
                        {
                            message = ParsePeakConverterLine(parts, headerIndices);
                        }
                        else
                        {
                            message = ParseStandardCSVLine(parts, headerIndices);
                        }
                        
                        if (message != null)
                        {
                            messages.Add(message);
                            if (messages.Count % 1000 == 0)
                                Console.WriteLine($"Загружено {messages.Count} сообщений...");
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Ошибка парсинга строки CSV: {line}. Ошибка: {ex.Message}");
                    }
                }
                
                Console.WriteLine($"Успешно загружено {messages.Count} сообщений из CSV");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Ошибка чтения CSV файла: {ex.Message}");
            }
            
            return messages;
        }

        private static CANMessage? ParsePeakConverterLine(string[] parts, Dictionary<string, int> headerIndices)
        {
            // Парсинг временной метки
            if (!headerIndices.ContainsKey("time"))
                return null;
                
            string timeStr = parts[headerIndices["time"]].Trim();
            timeStr = timeStr.Replace(',', '.'); // Заменяем запятую на точку для парсинга
            
            if (!double.TryParse(timeStr, NumberStyles.Any, CultureInfo.InvariantCulture, out double timestampMs))
                return null;
                
            // Парсинг ID
            if (!headerIndices.ContainsKey("id"))
                return null;
                
            string idStr = parts[headerIndices["id"]].Trim();
            idStr = idStr.Replace("0x", "").Replace("0X", "");
            
            if (!uint.TryParse(idStr, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out uint id))
                return null;
            
            // Определяем DLC
            int dlc = 8; // значение по умолчанию
            if (headerIndices.ContainsKey("dlc"))
            {
                if (int.TryParse(parts[headerIndices["dlc"]].Trim(), out int parsedDlc) && parsedDlc > 0)
                    dlc = Math.Min(parsedDlc, 64); // Ограничиваем для CAN FD
            }
            
            // Собираем данные
            var dataBytes = new List<byte>();
            
            // Пробуем получить данные из колонок D0, D1, ...
            for (int i = 0; i < dlc; i++)
            {
                string dataKey = $"d{i}";
                if (headerIndices.ContainsKey(dataKey) && headerIndices[dataKey] < parts.Length)
                {
                    string byteStr = parts[headerIndices[dataKey]].Trim();
                    if (!string.IsNullOrEmpty(byteStr) && byteStr.Length >= 2)
                    {
                        // Берем первые 2 символа если больше
                        string hexByte = byteStr.Length > 2 ? byteStr.Substring(0, 2) : byteStr;
                        if (byte.TryParse(hexByte, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out byte byteValue))
                        {
                            dataBytes.Add(byteValue);
                        }
                    }
                }
            }
            
            // Если не нашли данные в отдельных колонках, ищем в других местах
            if (dataBytes.Count == 0)
            {
                // Ищем первую колонку с hex данными после заголовков
                for (int i = 0; i < parts.Length; i++)
                {
                    if (i == headerIndices["time"] || i == headerIndices["id"] || 
                        (headerIndices.ContainsKey("dlc") && i == headerIndices["dlc"]) ||
                        (headerIndices.ContainsKey("channel") && i == headerIndices["channel"]))
                        continue;
                        
                    string byteStr = parts[i].Trim();
                    if (!string.IsNullOrEmpty(byteStr) && byteStr.Length == 2 && 
                        byte.TryParse(byteStr, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out byte byteValue))
                    {
                        dataBytes.Add(byteValue);
                        if (dataBytes.Count >= dlc)
                            break;
                    }
                }
            }
            
            // Если данных все еще нет, создаем массив нулей
            if (dataBytes.Count == 0)
            {
                dataBytes = Enumerable.Repeat((byte)0, dlc).ToList();
            }
            
            // Определяем тип CAN (CAN или CANFD)
            CANType canType = dlc > 8 ? CANType.CANFD : CANType.CAN;
            
            return new CANMessage
            {
                Timestamp = timestampMs / 1000.0, // конвертируем ms в секунды
                ID = id,
                DLC = dlc,
                Data = dataBytes.ToArray(),
                Channel = headerIndices.ContainsKey("channel") && headerIndices["channel"] < parts.Length
                    ? $"CAN{parts[headerIndices["channel"]].Trim()}" : "CAN1",
                CANType = canType
            };
        }

        private static CANMessage? ParseStandardCSVLine(string[] parts, Dictionary<string, int> headerIndices)
        {
            // Парсинг временной метки
            if (!headerIndices.ContainsKey("time"))
                return null;
                
            string timeStr = parts[headerIndices["time"]].Trim();
            timeStr = timeStr.Replace(',', '.'); // Заменяем запятую на точку для парсинга
            
            if (!double.TryParse(timeStr, NumberStyles.Any, CultureInfo.InvariantCulture, out double timestamp))
                return null;
                
            // Парсинг ID
            if (!headerIndices.ContainsKey("id"))
                return null;
                
            string idStr = parts[headerIndices["id"]].Trim();
            if (string.IsNullOrEmpty(idStr))
                return null;
                
            // Убираем префиксы
            idStr = idStr.Replace("0x", "").Replace("0X", "");
            
            if (!uint.TryParse(idStr, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out uint id))
                return null;
            
            // Определяем DLC
            int dlc = 8;
            if (headerIndices.ContainsKey("dlc") && headerIndices["dlc"] < parts.Length)
            {
                string dlcStr = parts[headerIndices["dlc"]].Trim();
                if (int.TryParse(dlcStr, out int parsedDlc))
                    dlc = parsedDlc;
            }
            
            // Собираем данные
            byte[] data;
            
            // Пробуем найти данные в колонке data
            if (headerIndices.ContainsKey("data") && headerIndices["data"] < parts.Length)
            {
                string dataStr = parts[headerIndices["data"]].Trim();
                data = ParseHexData(dataStr, dlc);
            }
            else
            {
                // Ищем hex данные в других колонках
                var dataBytes = new List<byte>();
                for (int i = 0; i < parts.Length; i++)
                {
                    if (i == headerIndices["time"] || i == headerIndices["id"] || 
                        (headerIndices.ContainsKey("dlc") && i == headerIndices["dlc"]) ||
                        (headerIndices.ContainsKey("channel") && i == headerIndices["channel"]))
                        continue;
                        
                    string byteStr = parts[i].Trim();
                    if (!string.IsNullOrEmpty(byteStr) && byteStr.Length >= 2)
                    {
                        // Берем первые 2 символа
                        string hexByte = byteStr.Length > 2 ? byteStr.Substring(0, 2) : byteStr;
                        if (byte.TryParse(hexByte, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out byte byteValue))
                        {
                            dataBytes.Add(byteValue);
                            if (dataBytes.Count >= dlc)
                                break;
                        }
                    }
                }
                
                if (dataBytes.Count == 0)
                    dataBytes = Enumerable.Repeat((byte)0, dlc).ToList();
                    
                data = dataBytes.ToArray();
            }
            
            // Определяем тип CAN (CAN или CANFD)
            CANType canType = dlc > 8 ? CANType.CANFD : CANType.CAN;
            
            return new CANMessage
            {
                Timestamp = timestamp,
                ID = id,
                DLC = dlc,
                Data = data,
                Channel = headerIndices.ContainsKey("channel") && headerIndices["channel"] < parts.Length
                    ? parts[headerIndices["channel"]].Trim() : "CAN1",
                CANType = canType
            };
        }

        public static List<CANMessage> ParseASC(string filePath)
        {
            var messages = new List<CANMessage>();
            
            try
            {
                Console.WriteLine($"Парсинг ASC файла: {filePath}");
                
                using var reader = new StreamReader(filePath);
                string? line;
                int lineCount = 0;
                
                while ((line = reader.ReadLine()) != null)
                {
                    lineCount++;
                    
                    // Пропускаем пустые строки и комментарии
                    if (string.IsNullOrWhiteSpace(line) || line.StartsWith("//"))
                        continue;
                    
                    // Проверяем, содержит ли строка CANFD
                    if (!line.Contains("CANFD"))
                        continue;
                    
                    try
                    {
                        // Анализируем структуру строки
                        CANMessage? message = ParseCANFDLine(line);
                        if (message != null)
                        {
                            messages.Add(message);
                            if (messages.Count % 1000 == 0)
                                Console.WriteLine($"Загружено {messages.Count} сообщений...");
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Ошибка парсинга строки ASC (строка {lineCount}): {line}. Ошибка: {ex.Message}");
                    }
                }
                
                Console.WriteLine($"Успешно загружено {messages.Count} сообщений из ASC");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Ошибка чтения ASC файла: {ex.Message}");
            }
            
            return messages;
        }

        private static CANMessage? ParseCANFDLine(string line)
        {
            // Пример строки:
            // "0.039718 CANFD   1 Rx        5B9                                   1 0 D 32 3E 7B 3E 7D 3E 8C 3E 86 3E 86 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00        0    0     3000        0        0        0        0        0"
            
            // Убираем лишние пробелы в начале и конце
            line = line.Trim();
            
            // Разделяем строку на части по пробелам
            var parts = line.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
            
            if (parts.Length < 10)
                return null;
            
            // Проверяем формат
            if (parts[1] != "CANFD")
                return null;
            
            // Парсим timestamp
            if (!double.TryParse(parts[0], NumberStyles.Any, CultureInfo.InvariantCulture, out double timestamp))
                return null;
            
            // Парсим канал
            if (!int.TryParse(parts[2], out int channel))
                channel = 1;
            
            // Направление (Rx/Tx) - parts[3]
            
            // Ищем ID (может быть с разным количеством символов)
            string idStr = parts[4];
            if (string.IsNullOrEmpty(idStr))
                return null;
            
            // Убираем возможные префиксы
            idStr = idStr.Replace("0x", "").Replace("0X", "");
            
            if (!uint.TryParse(idStr, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out uint id))
                return null;
            
            // Теперь нужно найти DLC и данные
            // Ищем индекс, где начинаются данные
            int dataStartIndex = -1;
            int dlc = 8; // по умолчанию
            
            // Проходим по частям, начиная с индекса 5
            for (int i = 5; i < parts.Length; i++)
            {
                string part = parts[i];
                
                // Пропускаем служебные флаги
                if (part == "1" || part == "0" || part == "Rx" || part == "Tx")
                    continue;
                
                // Если это буква D, E, A - это индикатор типа данных
                if (part == "D" || part == "E" || part == "A" || part == "8")
                {
                    // Следующая часть должна быть DLC в hex
                    if (i + 1 < parts.Length)
                    {
                        string dlcStr = parts[i + 1];
                        if (dlcStr.Length <= 2 && IsHexByte(dlcStr))
                        {
                            // Парсим DLC
                            if (int.TryParse(dlcStr, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out dlc))
                            {
                                // Данные начинаются через 2 позиции
                                dataStartIndex = i + 2;
                                break;
                            }
                        }
                        else if (dlcStr.Length <= 2 && int.TryParse(dlcStr, out dlc))
                        {
                            // DLC в десятичном формате
                            dataStartIndex = i + 2;
                            break;
                        }
                    }
                }
                // Если это hex число (1-2 символа) и следующая часть тоже hex число
                else if (part.Length <= 2 && IsHexByte(part))
                {
                    // Проверяем, не является ли это DLC
                    if (i + 1 < parts.Length)
                    {
                        string nextPart = parts[i + 1];
                        if (nextPart.Length <= 2 && IsHexByte(nextPart))
                        {
                            // Первое число - тип, второе - DLC
                            if (int.TryParse(nextPart, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out dlc))
                            {
                                dataStartIndex = i + 2;
                                break;
                            }
                        }
                    }
                }
                
                // Если мы дошли до hex-байта данных (2 символа)
                if (part.Length == 2 && IsHexByte(part))
                {
                    // Это начало данных, DLC не найден, используем значение по умолчанию
                    dataStartIndex = i;
                    break;
                }
            }
            
            if (dataStartIndex == -1 || dataStartIndex >= parts.Length)
                return null;
            
            // Собираем данные
            var dataBytes = new List<byte>();
            
            for (int i = dataStartIndex; i < parts.Length && dataBytes.Count < 64; i++)
            {
                string part = parts[i];
                
                // Если это hex-байт (2 символа)
                if (part.Length == 2 && IsHexByte(part))
                {
                    if (byte.TryParse(part, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out byte byteValue))
                    {
                        dataBytes.Add(byteValue);
                    }
                }
                // Если это длинная строка hex (слипшиеся данные)
                else if (part.Length > 2)
                {
                    // Проверяем, не является ли это служебным полем (например, "3000")
                    if (int.TryParse(part, out int _))
                    {
                        // Это число, не данные
                        break;
                    }
                    
                    // Разделяем слипшиеся hex данные
                    for (int j = 0; j < part.Length; j += 2)
                    {
                        if (j + 1 < part.Length)
                        {
                            string hexPair = part.Substring(j, 2);
                            if (IsHexByte(hexPair))
                            {
                                if (byte.TryParse(hexPair, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out byte byteValue))
                                {
                                    dataBytes.Add(byteValue);
                                    if (dataBytes.Count >= dlc)
                                        break;
                                }
                            }
                        }
                    }
                }
                else
                {
                    // Если встретили не hex данные, останавливаемся
                    break;
                }
                
                // Если собрали достаточно данных по DLC, выходим
                if (dataBytes.Count >= dlc)
                    break;
            }
            
            // Корректируем DLC по фактическому количеству данных
            if (dataBytes.Count > 0)
            {
                dlc = Math.Min(dlc, dataBytes.Count);
            }
            
            // Дополняем нулями если нужно
            while (dataBytes.Count < dlc)
            {
                dataBytes.Add(0);
            }
            
            // Определяем тип CAN
            CANType canType = dlc > 8 ? CANType.CANFD : CANType.CAN;
            
            return new CANMessage
            {
                Timestamp = timestamp,
                ID = id,
                DLC = dlc,
                Data = dataBytes.ToArray(),
                Channel = $"CAN{channel}",
                IsExtended = idStr.Length > 3,
                CANType = canType
            };
        }

        public static List<CANMessage> ParseBLF(string filePath)
        {
            var messages = new List<CANMessage>();
            
            try
            {
                Console.WriteLine("BLF парсинг еще не реализован полностью. Возвращаю пустой список.");
                // TODO: Реализовать полноценный парсинг BLF
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Ошибка чтения BLF файла: {ex.Message}");
            }
            
            return messages;
        }

        private static byte[] ParseHexData(string hexData, int dlc)
        {
            if (string.IsNullOrEmpty(hexData))
                return new byte[dlc];
                
            try
            {
                // Убираем все пробелы и не-hex символы
                hexData = Regex.Replace(hexData, "[^0-9A-Fa-f]", "");
                
                // Если строка пустая, возвращаем нули
                if (string.IsNullOrEmpty(hexData))
                    return new byte[dlc];
                
                // Дополняем до четной длины
                if (hexData.Length % 2 != 0)
                    hexData = "0" + hexData;
                
                // Создаем массив байт
                int byteCount = hexData.Length / 2;
                int actualDlc = Math.Min(dlc, byteCount);
                var data = new byte[actualDlc];
                
                for (int i = 0; i < actualDlc; i++)
                {
                    string byteStr = hexData.Substring(i * 2, 2);
                    if (byte.TryParse(byteStr, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out byte byteValue))
                    {
                        data[i] = byteValue;
                    }
                }
                
                // Если нужно, дополняем нулями
                if (actualDlc < dlc)
                {
                    var paddedData = new byte[dlc];
                    Array.Copy(data, paddedData, actualDlc);
                    return paddedData;
                }
                
                return data;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Ошибка парсинга hex данных: {hexData}. Ошибка: {ex.Message}");
                return new byte[dlc];
            }
        }

        private static bool IsHexByte(string str)
        {
            if (str.Length != 2)
                return false;
                
            foreach (char c in str)
            {
                if (!((c >= '0' && c <= '9') || 
                      (c >= 'A' && c <= 'F') || 
                      (c >= 'a' && c <= 'f')))
                {
                    return false;
                }
            }
            return true;
        }
        
        private static bool IsHexNumber(string str)
        {
            if (string.IsNullOrEmpty(str))
                return false;
            
            str = str.Trim();
            
            // Убираем префикс 0x если есть
            if (str.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                str = str.Substring(2);
            }
            
            // Проверяем, что все символы hex
            foreach (char c in str)
            {
                if (!((c >= '0' && c <= '9') || 
                      (c >= 'A' && c <= 'F') || 
                      (c >= 'a' && c <= 'f')))
                {
                    return false;
                }
            }
            
            return str.Length > 0;
        }
        
        public static LogFormat DetectFormat(string filePath)
        {
            string extension = Path.GetExtension(filePath).ToLower();
            
            if (extension == ".csv")
            {
                try
                {
                    using var reader = new StreamReader(filePath);
                    for (int i = 0; i < 10; i++)
                    {
                        string? line = reader.ReadLine();
                        if (line == null) break;
                        
                        if (line.Contains("PEAK-Converter") || line.Contains("ID/PID (hex)") || 
                            line.StartsWith("Number,Time (ms)"))
                        {
                            Console.WriteLine("Определен формат: CSV (PEAK-Converter)");
                            return LogFormat.CSV;
                        }
                    }
                }
                catch { }
                
                Console.WriteLine("Определен формат: CSV (стандартный)");
                return LogFormat.CSV;
            }
            else if (extension == ".asc")
            {
                try
                {
                    using var reader = new StreamReader(filePath);
                    for (int i = 0; i < 5; i++)
                    {
                        string? line = reader.ReadLine();
                        if (line == null) break;
                        
                        if (line.Contains("CANFD") || line.Contains("base hex") || line.StartsWith("    "))
                        {
                            Console.WriteLine("Определен формат: ASC (Vector)");
                            return LogFormat.ASC;
                        }
                    }
                }
                catch { }
                
                Console.WriteLine("Определен формат: ASC (стандартный)");
                return LogFormat.ASC;
            }
            else if (extension == ".blf")
            {
                Console.WriteLine("Определен формат: BLF");
                return LogFormat.BLF;
            }
            
            Console.WriteLine("Неизвестный формат, используем CSV");
            return LogFormat.CSV;
        }
    }
}