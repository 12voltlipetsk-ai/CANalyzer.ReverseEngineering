CANalyzer_ASC_OK_Analyze_OK_Generate_BIT_ok_DBC_OK ML_OFF
CANalyzer проект под Windows
https://github.com/12voltlipetsk-ai/12Volt/tree/main/CANalyzer
Automated Payload Reverse Engineering Pipeline for the Controller Area Network (CAN) protocol
https://github.com/brent-stone/CAN_Reverse_Engineering
cd "C:\Users\rveremeev\Documents\CANalyzer"
dotnet clean
dotnet build .\CANalyzer.WPF\CANalyzer.WPF.csproj
dotnet run --project .\CANalyzer.WPF\
Приложение позволяет загружать CAN логи в форматах CSV/ASC, 
анализировать их 
и автоматически генерировать DBC файлы с обнаруженными сигналами.


C:\Users\rveremeev\Documents\CANalyzer\
├── Directory.Build.props ✓
├── build_and_run.bat ✓
├── CANalyzer.sln ✓
├── CANalyzer.Core\ ✓
│   ├── CANalyzer.Core.csproj ✓
│   ├── Models\ ✓
│   │   ├── CANMessage.cs  ✓
│   │   ├── CANSignal.cs   ✓
│   │   ├── MessageStatistics.cs  ✓
│   │   └── Enums.cs   ✓
│   ├── Analyzers\ ✓
│   │   ├── StatisticalAnalyzer.cs ✓
│   │   └── SignalDetector.cs ✓
│   ├── Parsers\ ✓
│   │   └── LogParser.cs  ✓
│   └── DBC\ ✓
│       └── DBCGenerator.cs  ✓
├── CANalyzer.WPF\ ✓
│   ├── CANalyzer.WPF.csproj ✓
│   ├── App.xaml  ✓
│   ├── App.xaml.cs ✓
│   ├── appsettings.json  ✓
│   ├
│   └── Views\ ✓
│       ├── MainWindow.xaml   ✓
│       ├── MainWindow.xaml.cs  ✓
│       ├── SettingsWindow.xaml  ✓ 
│       └── SettingsWindow.xaml.cs   ✓
├── CANalyzer.ML\ ✓
│   ├── CANalyzer.ML.csproj  ✓
│   └── NeuralNetworks\ ✓
│       └── SignalClassifier.cs  ✓
├── CANalyzer.Correlation\
│   ├── CANalyzer.Correlation.csproj ✓
│   └── Analyzers\ ✓
│       └── CorrelationAnalyzer.cs ✓ 
├── CANalyzer.Tests\ ✓
│   ├── CANalyzer.Tests.csproj ✓
│   └── SignalDetectorTests.cs ✓
│── CANalyzer.Scripts\ ✓
│     ├── CANalyzer.Scripts.csproj ✓
│     └── Program.cs ✓
├── CANalyzer.ReverseEngineering\
│   ├── CANalyzer.ReverseEngineering.csproj
│   ├── Models\
│   │   ├── ArbID.cs
│   │   ├── Signal.cs
│   │   └── J1979Parameter.cs
│   ├── Analyzers\
│   │   ├── CANPreProcessor.cs
│   │   ├── CANLexicalAnalyzer.cs
│   │   └── CANSemanticAnalyzer.cs
│   └── Utils\
│       └── HierarchicalClustering.cs


PS C:\Users\rveremeev\Documents\CANalyzer> # Создаем базовую структуру
>> $basePath = "C:\Users\rveremeev\Documents\CANalyzer"
>> New-Item -ItemType Directory -Path $basePath -Force
>>
>> # Основные проекты
>> @(
>>     "CANalyzer.Core",
>>     "CANalyzer.WPF",
>>     "CANalyzer.ML",
>>     "CANalyzer.Correlation",
>>     "CANalyzer.Tests",
>>     "CANalyzer.Scripts"
>> ) | ForEach-Object { New-Item -ItemType Directory -Path "$basePath\$_" -Force }
>>
>> # Создаем файл решения
>> New-Item -ItemType File -Path "$basePath\CANalyzer.sln" -Force
>>
>> # CANalyzer.Core структура
>> @(
>>     "CANalyzer.Core\Models",
>>     "CANalyzer.Core\Analyzers",
>>     "CANalyzer.Core\Parsers",
>>     "CANalyzer.Core\DBC"
>> ) | ForEach-Object { New-Item -ItemType Directory -Path "$basePath\$_" -Force }
>>
>> # CANalyzer.Core файлы
>> @(
>>     "CANalyzer.Core\CANalyzer.Core.csproj",
>>     "CANalyzer.Core\Models\CANMessage.cs",
>>     "CANalyzer.Core\Models\CANSignal.cs",
>>     "CANalyzer.Core\Models\MessageStatistics.cs",
>>     "CANalyzer.Core\Models\Enums.cs",
>>     "CANalyzer.Core\Analyzers\StatisticalAnalyzer.cs",
>>     "CANalyzer.Core\Analyzers\SignalDetector.cs",
>>     "CANalyzer.Core\Parsers\LogParser.cs",
>>     "CANalyzer.Core\DBC\DBCGenerator.cs"
>> ) | ForEach-Object { New-Item -ItemType File -Path "$basePath\$_" -Force }
>>
>> # CANalyzer.WPF структура
>> New-Item -ItemType Directory -Path "$basePath\CANalyzer.WPF\Views" -Force
>>
>> # CANalyzer.WPF файлы
>> @(
>>     "CANalyzer.WPF\CANalyzer.WPF.csproj",
>>     "CANalyzer.WPF\App.xaml",
>>     "CANalyzer.WPF\App.xaml.cs",
>>     "CANalyzer.WPF\appsettings.json",
>>     "CANalyzer.WPF\Views\MainWindow.xaml",
>>     "CANalyzer.WPF\Views\MainWindow.xaml.cs"
>> ) | ForEach-Object { New-Item -ItemType File -Path "$basePath\$_" -Force }
>>
>> # CANalyzer.ML структура
>> New-Item -ItemType Directory -Path "$basePath\CANalyzer.ML\NeuralNetworks" -Force
>>
>> @(
>>     "CANalyzer.ML\CANalyzer.ML.csproj",
>>     "CANalyzer.ML\NeuralNetworks\SignalClassifier.cs"
>> ) | ForEach-Object { New-Item -ItemType File -Path "$basePath\$_" -Force }
>>
>> # CANalyzer.Correlation структура
>> New-Item -ItemType Directory -Path "$basePath\CANalyzer.Correlation\Analyzers" -Force
>>
>> @(
>>     "CANalyzer.Correlation\CANalyzer.Correlation.csproj",
>>     "CANalyzer.Correlation\Analyzers\CorrelationAnalyzer.cs"
>> ) | ForEach-Object { New-Item -ItemType File -Path "$basePath\$_" -Force }
>>
>> # CANalyzer.Tests файлы
>> @(
>>     "CANalyzer.Tests\CANalyzer.Tests.csproj",
>>     "CANalyzer.Tests\SignalDetectorTests.cs"
>> ) | ForEach-Object { New-Item -ItemType File -Path "$basePath\$_" -Force }
>>
>> # CANalyzer.Scripts файлы
>> @(
>>     "CANalyzer.Scripts\CANalyzer.Scripts.csproj",
>>     "CANalyzer.Scripts\Program.cs"
>> ) | ForEach-Object { New-Item -ItemType File -Path "$basePath\$_" -Force }
>>
>> Write-Host "Структура создана успешно!" -ForegroundColor Green


    Каталог: C:\Users\rveremeev\Documents


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        07.12.2025     20:04                CANalyzer


    Каталог: C:\Users\rveremeev\Documents\CANalyzer


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        07.12.2025     20:04                CANalyzer.Core
d-----        07.12.2025     20:04                CANalyzer.WPF
d-----        07.12.2025     20:04                CANalyzer.ML
d-----        07.12.2025     20:04                CANalyzer.Correlation
d-----        07.12.2025     20:04                CANalyzer.Tests
d-----        07.12.2025     20:04                CANalyzer.Scripts
-a----        07.12.2025     20:05              0 CANalyzer.sln


    Каталог: C:\Users\rveremeev\Documents\CANalyzer\CANalyzer.Core


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        07.12.2025     20:04                Models
d-----        07.12.2025     20:04                Analyzers
d-----        07.12.2025     20:04                Parsers
d-----        07.12.2025     20:04                DBC
-a----        07.12.2025     20:05              0 CANalyzer.Core.csproj


    Каталог: C:\Users\rveremeev\Documents\CANalyzer\CANalyzer.Core\Models


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        07.12.2025     20:05              0 CANMessage.cs
-a----        07.12.2025     20:05              0 CANSignal.cs
-a----        07.12.2025     20:05              0 MessageStatistics.cs
-a----        07.12.2025     20:05              0 Enums.cs


    Каталог: C:\Users\rveremeev\Documents\CANalyzer\CANalyzer.Core\Analyzers


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        07.12.2025     20:05              0 StatisticalAnalyzer.cs
-a----        07.12.2025     20:05              0 SignalDetector.cs


    Каталог: C:\Users\rveremeev\Documents\CANalyzer\CANalyzer.Core\Parsers


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        07.12.2025     20:05              0 LogParser.cs


    Каталог: C:\Users\rveremeev\Documents\CANalyzer\CANalyzer.Core\DBC


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        07.12.2025     20:05              0 DBCGenerator.cs


    Каталог: C:\Users\rveremeev\Documents\CANalyzer\CANalyzer.WPF


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        07.12.2025     20:04                Views
-a----        07.12.2025     20:05              0 CANalyzer.WPF.csproj
-a----        07.12.2025     20:05              0 App.xaml
-a----        07.12.2025     20:05              0 App.xaml.cs
-a----        07.12.2025     20:05              0 appsettings.json


    Каталог: C:\Users\rveremeev\Documents\CANalyzer\CANalyzer.WPF\Views


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        07.12.2025     20:05              0 MainWindow.xaml
-a----        07.12.2025     20:05              0 MainWindow.xaml.cs


    Каталог: C:\Users\rveremeev\Documents\CANalyzer\CANalyzer.ML


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        07.12.2025     20:04                NeuralNetworks
-a----        07.12.2025     20:05              0 CANalyzer.ML.csproj


    Каталог: C:\Users\rveremeev\Documents\CANalyzer\CANalyzer.ML\NeuralNetworks


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        07.12.2025     20:05              0 SignalClassifier.cs


    Каталог: C:\Users\rveremeev\Documents\CANalyzer\CANalyzer.Correlation


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        07.12.2025     20:04                Analyzers
-a----        07.12.2025     20:05              0 CANalyzer.Correlation.csproj


    Каталог: C:\Users\rveremeev\Documents\CANalyzer\CANalyzer.Correlation\Analyzers


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        07.12.2025     20:05              0 CorrelationAnalyzer.cs


    Каталог: C:\Users\rveremeev\Documents\CANalyzer\CANalyzer.Tests


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        07.12.2025     20:05              0 CANalyzer.Tests.csproj
-a----        07.12.2025     20:05              0 SignalDetectorTests.cs


    Каталог: C:\Users\rveremeev\Documents\CANalyzer\CANalyzer.Scripts


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        07.12.2025     20:05              0 CANalyzer.Scripts.csproj
-a----        07.12.2025     20:05              0 Program.cs
Структура создана успешно!


PS C:\Users\rveremeev\Documents\CANalyzer>

Порядок интеграции компонентов в MainWindow:
Загрузка лога → LogParser.Parse()

Анализ статистики → StatisticalAnalyzer.CalculateStatistics()

Детекция сигналов → SignalDetector.DetectSignals()

ML классификация → SignalClassifier.ClassifySignal()

Корреляционный анализ → CorrelationAnalyzer.AnalyzeCorrelations()

Генерация DBC → DBCGenerator.GenerateDBCFile()

Отображение в 3 окнах (сырые данные, декодированные сигналы, корреляции)
Стоит обратить внимание, что в текущем описании упоминаются 6 проектов!
 неупрощай код! Создай полное рабочее приложение
Используй для обучения модели следующие ресурсы
https://github.com/commaai/opendbc/tree/master/opendbc/dbc
https://github.com/BYDcar/opendbc-byd/tree/master
https://github.com/JejuSoul/OBD-PIDs-for-HKMC-EVs/
https://github.com/GENIVI/CANdevStudio?tab=readme-ov-file#can-signals
https://github.com/kommuai/bukapilot/tree/snapshot/opendbc
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

Directory.Build.props///////////////////////////////////////////////////////////
<Project>
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <OutputPath>bin\$(Configuration)\</OutputPath>
  </PropertyGroup>
</Project>
////////////////////////////////////////////////////////////////////////////////

build_and_run.bat//////////////////////////////////////////////////////////////
@echo off
echo Building CANalyzer solution...
echo.

REM Переходим в папку с проектом
cd /d "C:\Users\rveremeev\Documents\CANalyzer"

REM Очистка предыдущих сборок
echo Cleaning previous builds...
dotnet clean
echo.

REM Восстановление пакетов
echo Restoring packages...
dotnet restore
echo.

REM Сборка проекта Core
echo Building Core project...
dotnet build CANalyzer.Core\CANalyzer.Core.csproj
if %ERRORLEVEL% NEQ 0 (
    echo Core project build failed!
    pause
    exit /b 1
)
echo.

REM Сборка проекта ML
echo Building ML project...
dotnet build CANalyzer.ML\CANalyzer.ML.csproj
if %ERRORLEVEL% NEQ 0 (
    echo ML project build failed!
    pause
    exit /b 1
)
echo.

REM Сборка проекта Correlation
echo Building Correlation project...
dotnet build CANalyzer.Correlation\CANalyzer.Correlation.csproj
if %ERRORLEVEL% NEQ 0 (
    echo Correlation project build failed!
    pause
    exit /b 1
)
echo.

REM Сборка проекта WPF
echo Building WPF project...
dotnet build CANalyzer.WPF\CANalyzer.WPF.csproj
if %ERRORLEVEL% NEQ 0 (
    echo WPF project build failed!
    pause
    exit /b 1
)
echo.

REM Сборка проекта ReverseEngineering
echo Building ReverseEngineering project...
dotnet build CANalyzer.ReverseEngineering\CANalyzer.ReverseEngineering.csproj
if %ERRORLEVEL% NEQ 0 (
    echo ReverseEngineering project build failed!
    pause
    exit /b 1
)
echo.

REM Проверка успешности сборки
echo Build successful! Starting application...
echo.
timeout /t 3 /nobreak >nul

REM Запуск приложения
dotnet run --project CANalyzer.WPF\CANalyzer.WPF.csproj
////////////////////////////////////////////////////////////////////////////////

CANalyzer.sln //////////////////////////////////////////////////////////////////
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31903.59
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "CANalyzer.Core", "CANalyzer.Core\CANalyzer.Core.csproj", "{8A4F8C3A-1D2B-4E7F-9A6D-5B3C8E7F1A2B}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "CANalyzer.WPF", "CANalyzer.WPF\CANalyzer.WPF.csproj", "{9B5F8C3A-2D3B-4E7F-9A6D-6C3D8E7F1A2C}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "CANalyzer.ML", "CANalyzer.ML\CANalyzer.ML.csproj", "{7C6F8C3A-3D4B-4E7F-9A6D-7D3E8E7F1A2D}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "CANalyzer.Correlation", "CANalyzer.Correlation\CANalyzer.Correlation.csproj", "{6D7F8C3A-4D5B-4E7F-9A6D-8E3F8E7F1A2E}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "CANalyzer.Tests", "CANalyzer.Tests\CANalyzer.Tests.csproj", "{B780FA5B-0F05-4C87-8943-7CFAEC41492C}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "CANalyzer.Scripts", "CANalyzer.Scripts\CANalyzer.Scripts.csproj", "{D0C283AB-FDFB-4165-80CE-049414FF1772}"
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "CANalyzer.ReverseEngineering", "CANalyzer.ReverseEngineering\CANalyzer.ReverseEngineering.csproj", "{E8F9A1B2-C3D4-4E5F-9A6B-7C8D9E0F1A2B}"
EndProject
EndProject
Global
    GlobalSection(SolutionConfigurationPlatforms) = preSolution
        Debug|Any CPU = Debug|Any CPU
        Debug|x86 = Debug|x86
        Release|Any CPU = Release|Any CPU
        Release|x86 = Release|x86
    EndGlobalSection
    GlobalSection(ProjectConfigurationPlatforms) = postSolution
        {8A4F8C3A-1D2B-4E7F-9A6D-5B3C8E7F1A2B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
        {8A4F8C3A-1D2B-4E7F-9A6D-5B3C8E7F1A2B}.Debug|Any CPU.Build.0 = Debug|Any CPU
        {8A4F8C3A-1D2B-4E7F-9A6D-5B3C8E7F1A2B}.Debug|x86.ActiveCfg = Debug|x86
        {8A4F8C3A-1D2B-4E7F-9A6D-5B3C8E7F1A2B}.Debug|x86.Build.0 = Debug|x86
        {8A4F8C3A-1D2B-4E7F-9A6D-5B3C8E7F1A2B}.Release|Any CPU.ActiveCfg = Release|Any CPU
        {8A4F8C3A-1D2B-4E7F-9A6D-5B3C8E7F1A2B}.Release|Any CPU.Build.0 = Release|Any CPU
        {8A4F8C3A-1D2B-4E7F-9A6D-5B3C8E7F1A2B}.Release|x86.ActiveCfg = Release|x86
        {8A4F8C3A-1D2B-4E7F-9A6D-5B3C8E7F1A2B}.Release|x86.Build.0 = Release|x86
        {9B5F8C3A-2D3B-4E7F-9A6D-6C3D8E7F1A2C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
        {9B5F8C3A-2D3B-4E7F-9A6D-6C3D8E7F1A2C}.Debug|Any CPU.Build.0 = Debug|Any CPU
        {9B5F8C3A-2D3B-4E7F-9A6D-6C3D8E7F1A2C}.Debug|x86.ActiveCfg = Debug|x86
        {9B5F8C3A-2D3B-4E7F-9A6D-6C3D8E7F1A2C}.Debug|x86.Build.0 = Debug|x86
        {9B5F8C3A-2D3B-4E7F-9A6D-6C3D8E7F1A2C}.Release|Any CPU.ActiveCfg = Release|Any CPU
        {9B5F8C3A-2D3B-4E7F-9A6D-6C3D8E7F1A2C}.Release|Any CPU.Build.0 = Release|Any CPU
        {9B5F8C3A-2D3B-4E7F-9A6D-6C3D8E7F1A2C}.Release|x86.ActiveCfg = Release|x86
        {9B5F8C3A-2D3B-4E7F-9A6D-6C3D8E7F1A2C}.Release|x86.Build.0 = Release|x86
        {7C6F8C3A-3D4B-4E7F-9A6D-7D3E8E7F1A2D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
        {7C6F8C3A-3D4B-4E7F-9A6D-7D3E8E7F1A2D}.Debug|Any CPU.Build.0 = Debug|Any CPU
        {7C6F8C3A-3D4B-4E7F-9A6D-7D3E8E7F1A2D}.Debug|x86.ActiveCfg = Debug|x86
        {7C6F8C3A-3D4B-4E7F-9A6D-7D3E8E7F1A2D}.Debug|x86.Build.0 = Debug|x86
        {7C6F8C3A-3D4B-4E7F-9A6D-7D3E8E7F1A2D}.Release|Any CPU.ActiveCfg = Release|Any CPU
        {7C6F8C3A-3D4B-4E7F-9A6D-7D3E8E7F1A2D}.Release|Any CPU.Build.0 = Release|Any CPU
        {7C6F8C3A-3D4B-4E7F-9A6D-7D3E8E7F1A2D}.Release|x86.ActiveCfg = Release|x86
        {7C6F8C3A-3D4B-4E7F-9A6D-7D3E8E7F1A2D}.Release|x86.Build.0 = Release|x86
        {6D7F8C3A-4D5B-4E7F-9A6D-8E3F8E7F1A2E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
        {6D7F8C3A-4D5B-4E7F-9A6D-8E3F8E7F1A2E}.Debug|Any CPU.Build.0 = Debug|Any CPU
        {6D7F8C3A-4D5B-4E7F-9A6D-8E3F8E7F1A2E}.Debug|x86.ActiveCfg = Debug|x86
        {6D7F8C3A-4D5B-4E7F-9A6D-8E3F8E7F1A2E}.Debug|x86.Build.0 = Debug|x86
        {6D7F8C3A-4D5B-4E7F-9A6D-8E3F8E7F1A2E}.Release|Any CPU.ActiveCfg = Release|Any CPU
        {6D7F8C3A-4D5B-4E7F-9A6D-8E3F8E7F1A2E}.Release|Any CPU.Build.0 = Release|Any CPU
        {6D7F8C3A-4D5B-4E7F-9A6D-8E3F8E7F1A2E}.Release|x86.ActiveCfg = Release|x86
        {6D7F8C3A-4D5B-4E7F-9A6D-8E3F8E7F1A2E}.Release|x86.Build.0 = Release|x86
        {B780FA5B-0F05-4C87-8943-7CFAEC41492C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
        {B780FA5B-0F05-4C87-8943-7CFAEC41492C}.Debug|Any CPU.Build.0 = Debug|Any CPU
        {B780FA5B-0F05-4C87-8943-7CFAEC41492C}.Debug|x86.ActiveCfg = Debug|x86
        {B780FA5B-0F05-4C87-8943-7CFAEC41492C}.Debug|x86.Build.0 = Debug|x86
        {B780FA5B-0F05-4C87-8943-7CFAEC41492C}.Release|Any CPU.ActiveCfg = Release|Any CPU
        {B780FA5B-0F05-4C87-8943-7CFAEC41492C}.Release|Any CPU.Build.0 = Release|Any CPU
        {B780FA5B-0F05-4C87-8943-7CFAEC41492C}.Release|x86.ActiveCfg = Release|x86
        {B780FA5B-0F05-4C87-8943-7CFAEC41492C}.Release|x86.Build.0 = Release|x86
        {D0C283AB-FDFB-4165-80CE-049414FF1772}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
        {D0C283AB-FDFB-4165-80CE-049414FF1772}.Debug|Any CPU.Build.0 = Debug|Any CPU
        {D0C283AB-FDFB-4165-80CE-049414FF1772}.Debug|x86.ActiveCfg = Debug|x86
        {D0C283AB-FDFB-4165-80CE-049414FF1772}.Debug|x86.Build.0 = Debug|x86
        {D0C283AB-FDFB-4165-80CE-049414FF1772}.Release|Any CPU.ActiveCfg = Release|Any CPU
        {D0C283AB-FDFB-4165-80CE-049414FF1772}.Release|Any CPU.Build.0 = Release|Any CPU
        {D0C283AB-FDFB-4165-80CE-049414FF1772}.Release|x86.ActiveCfg = Release|x86
        {D0C283AB-FDFB-4165-80CE-049414FF1772}.Release|x86.Build.0 = Release|x86
        {E8F9A1B2-C3D4-4E5F-9A6B-7C8D9E0F1A2B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
        {E8F9A1B2-C3D4-4E5F-9A6B-7C8D9E0F1A2B}.Debug|Any CPU.Build.0 = Debug|Any CPU
        {E8F9A1B2-C3D4-4E5F-9A6B-7C8D9E0F1A2B}.Debug|x86.ActiveCfg = Debug|x86
        {E8F9A1B2-C3D4-4E5F-9A6B-7C8D9E0F1A2B}.Debug|x86.Build.0 = Debug|x86
        {E8F9A1B2-C3D4-4E5F-9A6B-7C8D9E0F1A2B}.Release|Any CPU.ActiveCfg = Release|Any CPU
        {E8F9A1B2-C3D4-4E5F-9A6B-7C8D9E0F1A2B}.Release|Any CPU.Build.0 = Release|Any CPU
        {E8F9A1B2-C3D4-4E5F-9A6B-7C8D9E0F1A2B}.Release|x86.ActiveCfg = Release|x86
        {E8F9A1B2-C3D4-4E5F-9A6B-7C8D9E0F1A2B}.Release|x86.Build.0 = Release|x86
    EndGlobalSection
    GlobalSection(SolutionProperties) = preSolution
        HideSolutionNode = FALSE
    EndGlobalSection
    GlobalSection(ExtensibilityGlobals) = postSolution
                SolutionGuid = {B8A4F8C3A-1D2B-4E7F-9A6D-5B3C8E7F1A2B}
        SolutionGuid = {1BF2469F-D3E8-471F-99B3-800F17F1EA51}
    EndGlobalSection
EndGlobal

///////////////////////////////////////////////////////////////////////////////////////////////

CANalyzer.Core.csproj/////////////////////////////////////////////////////////////////////////
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <Platforms>AnyCPU;x86</Platforms>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="CsvHelper" Version="30.0.1" />
    <PackageReference Include="MathNet.Numerics" Version="5.0.0" />
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
    <PackageReference Include="System.Collections.Immutable" Version="8.0.0" />
  </ItemGroup>
</Project>
//////////////////////////////////////////////////////////////////////////////////////////////

CANMessage.cs/////////////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;

namespace CANalyzer.Core.Models
{
    public class CANMessage
    {
        public uint ID { get; set; }
        public string Name { get; set; } = string.Empty;
        public int DLC { get; set; }
        public byte[] Data { get; set; } = Array.Empty<byte>();
        public double Timestamp { get; set; }
        public string Channel { get; set; } = "CAN1";
        public bool IsExtended { get; set; }
        public bool IsRemoteFrame { get; set; }
        public List<CANSignal> Signals { get; set; } = new List<CANSignal>();
        public int CycleTime { get; set; }
        public double Frequency { get; set; }
        
        // ДОБАВЛЕНО: Свойство для отображения данных в шестнадцатеричном формате
        public string DataHex 
        { 
            get
            {
                if (Data == null || Data.Length == 0)
                    return string.Empty;
                    
                int bytesToShow = Math.Min(DLC, Data.Length);
                return BitConverter.ToString(Data, 0, bytesToShow).Replace("-", " ");
            }
        }
        
        // ДОБАВЛЕНО: Свойство для отображения количества сигналов
        public int SignalsCount => Signals?.Count ?? 0;
        
        // ДОБАВЛЕНО: Свойство для типа CAN (CAN или CANFD)
        public CANType CANType { get; set; } = CANType.CAN;

        public override string ToString()
        {
            return $"{Timestamp:F6} {Channel} {ID:X3} [{DLC}] {DataHex}";
        }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////

CANSignal.cs//////////////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;

namespace CANalyzer.Core.Models
{
    public class CANSignal
    {
        public string Name { get; set; } = string.Empty;
        public int StartBit { get; set; }
        public int Length { get; set; }
        public ByteOrder ByteOrder { get; set; }
        public SignalValueType ValueType { get; set; }
        public double Factor { get; set; } = 1.0;
        public double Offset { get; set; } = 0.0;
        public double Minimum { get; set; }
        public double Maximum { get; set; }
        public string Unit { get; set; } = string.Empty;
        public SignalType SignalType { get; set; }
        public SignalClassification Classification { get; set; }
        public uint MessageID { get; set; }
        public Dictionary<uint, string> ValueTable { get; set; } = new Dictionary<uint, string>();
        public List<double> RawValues { get; set; } = new List<double>();
        public List<double> PhysicalValues { get; set; } = new List<double>();
        
        public double GetPhysicalValue(double rawValue)
        {
            return rawValue * Factor + Offset;
        }
        
        public override string ToString()
        {
            return $"{Name} ({StartBit}:{Length}) {SignalType} [{Minimum:F2}..{Maximum:F2}] {Unit}";
        }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////

MessageStatistics.cs//////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;

namespace CANalyzer.Core.Models
{
    public class MessageStatistics
    {
        public uint ID { get; set; }
        public string Name { get; set; } = string.Empty;
        public long Count { get; set; }
        public double Frequency { get; set; }
        public double MinInterval { get; set; }
        public double MaxInterval { get; set; }
        public double AvgInterval { get; set; }
        public double FirstSeen { get; set; }
        public double LastSeen { get; set; }
        public Dictionary<byte, long> DataPatterns { get; set; } = new Dictionary<byte, long>();
        public List<double> Timestamps { get; set; } = new List<double>();
        public double Jitter { get; set; }
        public bool IsCyclic { get; set; }
        public int EstimatedCycleTime { get; set; }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////

Enums.cs//////////////////////////////////////////////////////////////////////////////////////
using System;

namespace CANalyzer.Core.Models
{
    public enum SignalType
    {
        Unknown,
        Boolean,
        Integer,
        Float,
        Enum
    }

    public enum ByteOrder
    {
        Intel,
        Motorola
    }

    // ИЗМЕНЕНО: переименовано во избежание конфликта с System.ValueType
    public enum SignalValueType
    {
        Signed,
        Unsigned
    }

    public enum LogFormat
    {
        CSV,
        ASC,
        BLF,
        MDF
    }

    public enum SignalClassification
    {
        Unknown,
        Sensor,
        Actuator,
        Status,
        Diagnostic,
        Control
    }

    // ДОБАВЛЕНО: новый enum для типа CAN сообщения
    public enum CANType
    {
        CAN,
        CANFD
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////

StatisticalAnalyzer.cs////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.Linq;
using CANalyzer.Core.Models;

namespace CANalyzer.Core.Analyzers
{
    public class StatisticalAnalyzer
    {
        public static List<MessageStatistics> CalculateStatistics(List<CANMessage> messages)
        {
            var statsDict = new Dictionary<uint, MessageStatistics>();
            var messageGroups = messages.GroupBy(m => m.ID);
            
            foreach (var group in messageGroups)
            {
                var timestamps = group.Select(m => m.Timestamp).OrderBy(t => t).ToList();
                var intervals = new List<double>();
                
                for (int i = 1; i < timestamps.Count; i++)
                {
                    intervals.Add(timestamps[i] - timestamps[i - 1]);
                }
                
                var stats = new MessageStatistics
                {
                    ID = group.Key,
                    Count = group.Count(),
                    FirstSeen = timestamps.First(),
                    LastSeen = timestamps.Last(),
                    Timestamps = timestamps,
                    Frequency = group.Count() / (timestamps.Last() - timestamps.First()),
                    MinInterval = intervals.Any() ? intervals.Min() : 0,
                    MaxInterval = intervals.Any() ? intervals.Max() : 0,
                    AvgInterval = intervals.Any() ? intervals.Average() : 0,
                    Jitter = intervals.Any() ? CalculateJitter(intervals) : 0,
                    IsCyclic = intervals.Any() && IsCyclicMessage(intervals),
                    EstimatedCycleTime = intervals.Any() ? (int)Math.Round(intervals.Average() * 1000) : 0
                };
                
                // Анализ паттернов данных
                foreach (var message in group)
                {
                    foreach (var b in message.Data)
                    {
                        if (stats.DataPatterns.ContainsKey(b))
                            stats.DataPatterns[b]++;
                        else
                            stats.DataPatterns[b] = 1;
                    }
                }
                
                statsDict[group.Key] = stats;
            }
            
            return statsDict.Values.ToList();
        }
        
        private static double CalculateJitter(List<double> intervals)
        {
            if (intervals.Count < 2) return 0;
            
            double mean = intervals.Average();
            double sumOfSquares = intervals.Sum(x => Math.Pow(x - mean, 2));
            return Math.Sqrt(sumOfSquares / intervals.Count);
        }
        
        private static bool IsCyclicMessage(List<double> intervals)
        {
            if (intervals.Count < 3) return false;
            
            double mean = intervals.Average();
            double tolerance = mean * 0.2; // 20% допуск
            
            return intervals.All(i => Math.Abs(i - mean) <= tolerance);
        }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////

SignalDetector.cs/////////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.Linq;
using CANalyzer.Core.Models;

namespace CANalyzer.Core.Analyzers
{
    public class SignalDetector
    {
        private const int MIN_BYTE_LENGTH = 1;
        private const int MAX_BYTE_LENGTH = 8;
        
        public static List<CANSignal> DetectSignals(List<CANMessage> messages, uint messageId)
        {
            var messageGroup = messages.Where(m => m.ID == messageId).ToList();
            if (messageGroup.Count < 2)
                return new List<CANSignal>();
            
            var signals = new List<CANSignal>();
            var allData = messageGroup.Select(m => m.Data).ToList();
            
            // Анализ каждого байта отдельно
            for (int byteIndex = 0; byteIndex < 8; byteIndex++)
            {
                DetectSignalInByte(allData, byteIndex, messageId, signals);
            }
            
            // Анализ мультибайтовых сигналов
            DetectMultiByteSignals(allData, messageId, signals);
            
            return signals;
        }
        
        private static void DetectSignalInByte(List<byte[]> allData, int byteIndex, 
            uint messageId, List<CANSignal> signals)
        {
            var byteValues = allData.Select(data => 
                byteIndex < data.Length ? data[byteIndex] : (byte)0).ToList();
            
            // Проверка на статический байт
            if (byteValues.All(v => v == byteValues[0]))
                return;
            
            // Проверка на вариативность
            if (IsMeaningfulByte(byteValues))
            {
                var signal = new CANSignal
                {
                    Name = $"Byte_{byteIndex}",
                    StartBit = byteIndex * 8, // Переводим в биты для совместимости
                    Length = 8, // 1 байт = 8 бит
                    ByteOrder = ByteOrder.Intel,
                    ValueType = SignalValueType.Unsigned,
                    SignalType = DetermineByteSignalType(byteValues),
                    MessageID = messageId,
                    Minimum = byteValues.Min(),
                    Maximum = byteValues.Max(),
                    Unit = DetermineByteUnit(byteValues)
                };
                
                // Автоматическое определение factor и offset
                AutoDetermineScaling(signal, byteValues.Select(v => (uint)v).ToList());
                
                signals.Add(signal);
            }
        }
        
        private static void DetectMultiByteSignals(List<byte[]> allData, uint messageId, 
            List<CANSignal> signals)
        {
            int dataLength = allData[0].Length;
            
            for (int startByte = 0; startByte < dataLength; startByte++)
            {
                for (int byteLength = 2; byteLength <= 4 && startByte + byteLength <= dataLength; byteLength++)
                {
                    int bitLength = byteLength * 8;
                    int startBit = startByte * 8;
                    
                    var signalValues = allData.Select(data => 
                        ExtractBytes(data, startByte, byteLength)).ToList();
                    
                    if (IsMeaningfulMultiByteSignal(signalValues))
                    {
                        // Проверяем, не перекрывается ли с уже обнаруженными сигналами
                        bool overlaps = signals.Any(s => 
                            (startBit >= s.StartBit && startBit < s.StartBit + s.Length) ||
                            (startBit + bitLength > s.StartBit && startBit + bitLength <= s.StartBit + s.Length));
                        
                        if (!overlaps)
                        {
                            var signal = new CANSignal
                            {
                                Name = $"MultiByte_{startByte}_{byteLength}",
                                StartBit = startBit,
                                Length = bitLength,
                                ByteOrder = DetermineMultiByteOrder(startByte, byteLength),
                                ValueType = SignalValueType.Unsigned,
                                SignalType = DetermineMultiByteSignalType(signalValues),
                                MessageID = messageId,
                                Minimum = signalValues.Min(),
                                Maximum = signalValues.Max(),
                                Unit = DetermineMultiByteUnit(signalValues)
                            };
                            
                            AutoDetermineScaling(signal, signalValues);
                            
                            signals.Add(signal);
                        }
                    }
                }
            }
        }
        
        private static uint ExtractBytes(byte[] data, int startByte, int byteLength)
        {
            if (data.Length < startByte + byteLength)
                return 0;
            
            uint result = 0;
            
            // Для Intel (little-endian) порядок
            for (int i = 0; i < byteLength; i++)
            {
                result |= (uint)data[startByte + i] << (i * 8);
            }
            
            return result;
        }
        
        private static bool IsMeaningfulByte(List<byte> values)
        {
            if (values.Distinct().Count() < 2)
                return false;
            
            // Проверка на изменение значений
            double variance = CalculateVariance(values.Select(v => (double)v).ToList());
            return variance > 1.0; // Эмпирический порог
        }
        
        private static bool IsMeaningfulMultiByteSignal(List<uint> values)
        {
            if (values.Distinct().Count() < 2)
                return false;
            
            // Проверка на монотонное изменение
            bool increasing = true;
            bool decreasing = true;
            
            for (int i = 1; i < values.Count; i++)
            {
                if (values[i] < values[i - 1])
                    increasing = false;
                if (values[i] > values[i - 1])
                    decreasing = false;
            }
            
            double variance = CalculateVariance(values.Select(v => (double)v).ToList());
            return (increasing || decreasing) && variance > 10.0;
        }
        
        private static double CalculateVariance(List<double> values)
        {
            if (values.Count < 2)
                return 0;
            
            double mean = values.Average();
            double sumOfSquares = values.Sum(x => Math.Pow(x - mean, 2));
            return sumOfSquares / values.Count;
        }
        
        private static ByteOrder DetermineMultiByteOrder(int startByte, int byteLength)
        {
            // Упрощенная логика: предполагаем Intel для большинства случаев
            return ByteOrder.Intel;
        }
        
        private static SignalType DetermineByteSignalType(List<byte> values)
        {
            var distinctValues = values.Distinct().Count();
            
            if (distinctValues <= 2)
                return SignalType.Boolean;
            else if (distinctValues <= 10)
                return SignalType.Enum;
            else if (values.Any(v => v > 127)) // Проверка на возможные отрицательные значения
                return SignalType.Integer;
            else
                return SignalType.Integer;
        }
        
        private static SignalType DetermineMultiByteSignalType(List<uint> values)
        {
            var distinctValues = values.Distinct().Count();
            
            if (distinctValues <= 2)
                return SignalType.Boolean;
            else if (distinctValues <= 10)
                return SignalType.Enum;
            else
                return SignalType.Integer;
        }
        
        private static string DetermineByteUnit(List<byte> values)
        {
            double range = values.Max() - values.Min();
            
            if (range < 10)
                return "enum";
            else if (range < 100)
                return "%";
            else if (range < 200)
                return "temp";
            else
                return "raw";
        }
        
        private static string DetermineMultiByteUnit(List<uint> values)
        {
            double range = values.Max() - values.Min();
            
            if (range < 100)
                return "enum";
            else if (range < 1000)
                return "%";
            else if (range < 10000)
                return "RPM";
            else if (range < 65535)
                return "speed";
            else
                return "raw";
        }
        
        private static void AutoDetermineScaling(CANSignal signal, List<uint> rawValues)
        {
            double minRaw = rawValues.Min();
            double maxRaw = rawValues.Max();
            
            // Простое масштабирование
            signal.Factor = 1.0;
            signal.Offset = 0.0;
            
            if (signal.SignalType == SignalType.Integer || signal.SignalType == SignalType.Float)
            {
                double range = maxRaw - minRaw;
                
                if (range > 0)
                {
                    // Масштабируем к диапазону 0-100 или другому "красивому" диапазону
                    if (range < 256) // 8-битное значение
                    {
                        signal.Factor = 100.0 / 255.0;
                        signal.Offset = 0;
                    }
                    else if (range < 65536) // 16-битное значение
                    {
                        signal.Factor = 1000.0 / 65535.0;
                        signal.Offset = 0;
                    }
                    // Для других случаев оставляем factor=1
                }
            }
        }

        // Оптимизированная версия для больших данных
        public static List<CANSignal> DetectSignalsOptimized(List<CANMessage> messages, uint messageId, 
            int sampleLimit = 100)
        {
            var messageGroup = messages.Where(m => m.ID == messageId).ToList();
            if (messageGroup.Count < 2)
                return new List<CANSignal>();
            
            // Если слишком много сообщений, берем выборку для производительности
            if (messageGroup.Count > sampleLimit)
            {
                var step = messageGroup.Count / sampleLimit;
                messageGroup = messageGroup
                    .Where((m, index) => index % step == 0)
                    .Take(sampleLimit)
                    .ToList();
            }
            
            var signals = new List<CANSignal>();
            var allData = messageGroup.Select(m => m.Data).ToList();
            
            // Анализ каждого байта отдельно
            for (int byteIndex = 0; byteIndex < 8; byteIndex++)
            {
                DetectSignalInByte(allData, byteIndex, messageId, signals);
            }
            
            // Анализ мультибайтовых сигналов (ограничиваем для производительности)
            DetectMultiByteSignalsOptimized(allData, messageId, signals);
            
            return signals;
        }

        private static void DetectMultiByteSignalsOptimized(List<byte[]> allData, uint messageId, 
            List<CANSignal> signals)
        {
            int dataLength = allData[0].Length;
            
            // Ограничиваем поиск для производительности
            int maxStartByte = Math.Min(dataLength, 6);
            
            for (int startByte = 0; startByte < maxStartByte; startByte++)
            {
                for (int byteLength = 2; byteLength <= 4 && startByte + byteLength <= dataLength; byteLength++)
                {
                    int bitLength = byteLength * 8;
                    int startBit = startByte * 8;
                    
                    var signalValues = allData.Select(data => 
                        ExtractBytes(data, startByte, byteLength)).ToList();
                    
                    if (IsMeaningfulMultiByteSignal(signalValues))
                    {
                        // Проверяем, не перекрывается ли с уже обнаруженными сигналами
                        bool overlaps = signals.Any(s => 
                            (startBit >= s.StartBit && startBit < s.StartBit + s.Length) ||
                            (startBit + bitLength > s.StartBit && startBit + bitLength <= s.StartBit + s.Length));
                        
                        if (!overlaps)
                        {
                            var signal = new CANSignal
                            {
                                Name = $"MultiByte_{startByte}_{byteLength}",
                                StartBit = startBit,
                                Length = bitLength,
                                ByteOrder = DetermineMultiByteOrder(startByte, byteLength),
                                ValueType = SignalValueType.Unsigned,
                                SignalType = DetermineMultiByteSignalType(signalValues),
                                MessageID = messageId,
                                Minimum = signalValues.Min(),
                                Maximum = signalValues.Max(),
                                Unit = DetermineMultiByteUnit(signalValues)
                            };
                            
                            AutoDetermineScaling(signal, signalValues);
                            
                            signals.Add(signal);
                        }
                    }
                }
            }
        }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////

LogParser.cs /////////////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using CANalyzer.Core.Models;

namespace CANalyzer.Core.Parsers
{
    public class LogParser
    {
        public static List<CANMessage> Parse(string filePath, LogFormat format)
        {
            return format switch
            {
                LogFormat.CSV => ParseCSV(filePath) ?? new List<CANMessage>(),
                LogFormat.ASC => ParseASC(filePath) ?? new List<CANMessage>(),
                LogFormat.BLF => ParseBLF(filePath) ?? new List<CANMessage>(),
                _ => new List<CANMessage>()
            };
        }

        public static List<CANMessage> ParseCSV(string filePath)
        {
            var messages = new List<CANMessage>();
            
            try
            {
                Console.WriteLine($"Парсинг CSV файла: {filePath}");
                
                using var reader = new StreamReader(filePath);
                string? line;
                bool headerProcessed = false;
                Dictionary<string, int> headerIndices = new Dictionary<string, int>();
                bool isPeakConverterFormat = false;

                while ((line = reader.ReadLine()) != null)
                {
                    // Пропускаем служебные строки в начале файла
                    if (line.StartsWith("$STARTTIME") || 
                        line.StartsWith("Start time") || 
                        line.StartsWith("C:\\") || 
                        line.Contains("Generated by") || 
                        line.Contains("Data imported") || 
                        line.StartsWith("---") || 
                        line.StartsWith("Glossary") || 
                        line.StartsWith("    ") || 
                        string.IsNullOrWhiteSpace(line))
                    {
                        if (line.Contains("PEAK-Converter"))
                        {
                            isPeakConverterFormat = true;
                            Console.WriteLine("Обнаружен формат PEAK-Converter");
                        }
                        continue;
                    }

                    var parts = line.Split(',');

                    // Обработка заголовка
                    if (!headerProcessed)
                    {
                        if (parts.Length > 5)
                        {
                            for (int i = 0; i < parts.Length; i++)
                            {
                                string header = parts[i].Trim().ToLower();
                                
                                if (header.Contains("time"))
                                    headerIndices["time"] = i;
                                else if (header.Contains("id") || header.Contains("pid"))
                                    headerIndices["id"] = i;
                                else if (header == "length" || header.Contains("dlc"))
                                    headerIndices["dlc"] = i;
                                else if (header == "bus" || header.Contains("bus") || header.Contains("channel"))
                                    headerIndices["channel"] = i;
                                else if (header.StartsWith("d") && (header.Length == 2 || header.Length == 3))
                                {
                                    // D0, D1, ..., D63
                                    headerIndices[header.ToLower()] = i;
                                }
                            }
                            
                            Console.WriteLine($"Найдены заголовки: {string.Join(", ", headerIndices.Keys)}");
                            
                            if (headerIndices.ContainsKey("time") && headerIndices.ContainsKey("id"))
                            {
                                headerProcessed = true;
                                continue;
                            }
                        }
                    }

                    // Пропускаем строки без данных
                    if (!headerProcessed || parts.Length < 3)
                        continue;

                    try
                    {
                        CANMessage? message = null;
                        
                        if (isPeakConverterFormat)
                        {
                            message = ParsePeakConverterLine(parts, headerIndices);
                        }
                        else
                        {
                            message = ParseStandardCSVLine(parts, headerIndices);
                        }
                        
                        if (message != null)
                        {
                            messages.Add(message);
                            if (messages.Count % 1000 == 0)
                                Console.WriteLine($"Загружено {messages.Count} сообщений...");
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Ошибка парсинга строки CSV: {line}. Ошибка: {ex.Message}");
                    }
                }
                
                Console.WriteLine($"Успешно загружено {messages.Count} сообщений из CSV");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Ошибка чтения CSV файла: {ex.Message}");
            }
            
            return messages;
        }

        private static CANMessage? ParsePeakConverterLine(string[] parts, Dictionary<string, int> headerIndices)
        {
            // Парсинг временной метки
            if (!headerIndices.ContainsKey("time"))
                return null;
                
            string timeStr = parts[headerIndices["time"]].Trim();
            timeStr = timeStr.Replace(',', '.'); // Заменяем запятую на точку для парсинга
            
            if (!double.TryParse(timeStr, NumberStyles.Any, CultureInfo.InvariantCulture, out double timestampMs))
                return null;
                
            // Парсинг ID
            if (!headerIndices.ContainsKey("id"))
                return null;
                
            string idStr = parts[headerIndices["id"]].Trim();
            idStr = idStr.Replace("0x", "").Replace("0X", "");
            
            if (!uint.TryParse(idStr, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out uint id))
                return null;
            
            // Определяем DLC
            int dlc = 8; // значение по умолчанию
            if (headerIndices.ContainsKey("dlc"))
            {
                if (int.TryParse(parts[headerIndices["dlc"]].Trim(), out int parsedDlc) && parsedDlc > 0)
                    dlc = Math.Min(parsedDlc, 64); // Ограничиваем для CAN FD
            }
            
            // Собираем данные
            var dataBytes = new List<byte>();
            
            // Пробуем получить данные из колонок D0, D1, ...
            for (int i = 0; i < dlc; i++)
            {
                string dataKey = $"d{i}";
                if (headerIndices.ContainsKey(dataKey) && headerIndices[dataKey] < parts.Length)
                {
                    string byteStr = parts[headerIndices[dataKey]].Trim();
                    if (!string.IsNullOrEmpty(byteStr) && byteStr.Length >= 2)
                    {
                        // Берем первые 2 символа если больше
                        string hexByte = byteStr.Length > 2 ? byteStr.Substring(0, 2) : byteStr;
                        if (byte.TryParse(hexByte, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out byte byteValue))
                        {
                            dataBytes.Add(byteValue);
                        }
                    }
                }
            }
            
            // Если не нашли данные в отдельных колонках, ищем в других местах
            if (dataBytes.Count == 0)
            {
                // Ищем первую колонку с hex данными после заголовков
                for (int i = 0; i < parts.Length; i++)
                {
                    if (i == headerIndices["time"] || i == headerIndices["id"] || 
                        (headerIndices.ContainsKey("dlc") && i == headerIndices["dlc"]) ||
                        (headerIndices.ContainsKey("channel") && i == headerIndices["channel"]))
                        continue;
                        
                    string byteStr = parts[i].Trim();
                    if (!string.IsNullOrEmpty(byteStr) && byteStr.Length == 2 && 
                        byte.TryParse(byteStr, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out byte byteValue))
                    {
                        dataBytes.Add(byteValue);
                        if (dataBytes.Count >= dlc)
                            break;
                    }
                }
            }
            
            // Если данных все еще нет, создаем массив нулей
            if (dataBytes.Count == 0)
            {
                dataBytes = Enumerable.Repeat((byte)0, dlc).ToList();
            }
            
            // Определяем тип CAN (CAN или CANFD)
            CANType canType = dlc > 8 ? CANType.CANFD : CANType.CAN;
            
            return new CANMessage
            {
                Timestamp = timestampMs / 1000.0, // конвертируем ms в секунды
                ID = id,
                DLC = dlc,
                Data = dataBytes.ToArray(),
                Channel = headerIndices.ContainsKey("channel") && headerIndices["channel"] < parts.Length
                    ? $"CAN{parts[headerIndices["channel"]].Trim()}" : "CAN1",
                CANType = canType
            };
        }

        private static CANMessage? ParseStandardCSVLine(string[] parts, Dictionary<string, int> headerIndices)
        {
            // Парсинг временной метки
            if (!headerIndices.ContainsKey("time"))
                return null;
                
            string timeStr = parts[headerIndices["time"]].Trim();
            timeStr = timeStr.Replace(',', '.'); // Заменяем запятую на точку для парсинга
            
            if (!double.TryParse(timeStr, NumberStyles.Any, CultureInfo.InvariantCulture, out double timestamp))
                return null;
                
            // Парсинг ID
            if (!headerIndices.ContainsKey("id"))
                return null;
                
            string idStr = parts[headerIndices["id"]].Trim();
            if (string.IsNullOrEmpty(idStr))
                return null;
                
            // Убираем префиксы
            idStr = idStr.Replace("0x", "").Replace("0X", "");
            
            if (!uint.TryParse(idStr, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out uint id))
                return null;
            
            // Определяем DLC
            int dlc = 8;
            if (headerIndices.ContainsKey("dlc") && headerIndices["dlc"] < parts.Length)
            {
                string dlcStr = parts[headerIndices["dlc"]].Trim();
                if (int.TryParse(dlcStr, out int parsedDlc))
                    dlc = parsedDlc;
            }
            
            // Собираем данные
            byte[] data;
            
            // Пробуем найти данные в колонке data
            if (headerIndices.ContainsKey("data") && headerIndices["data"] < parts.Length)
            {
                string dataStr = parts[headerIndices["data"]].Trim();
                data = ParseHexData(dataStr, dlc);
            }
            else
            {
                // Ищем hex данные в других колонках
                var dataBytes = new List<byte>();
                for (int i = 0; i < parts.Length; i++)
                {
                    if (i == headerIndices["time"] || i == headerIndices["id"] || 
                        (headerIndices.ContainsKey("dlc") && i == headerIndices["dlc"]) ||
                        (headerIndices.ContainsKey("channel") && i == headerIndices["channel"]))
                        continue;
                        
                    string byteStr = parts[i].Trim();
                    if (!string.IsNullOrEmpty(byteStr) && byteStr.Length >= 2)
                    {
                        // Берем первые 2 символа
                        string hexByte = byteStr.Length > 2 ? byteStr.Substring(0, 2) : byteStr;
                        if (byte.TryParse(hexByte, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out byte byteValue))
                        {
                            dataBytes.Add(byteValue);
                            if (dataBytes.Count >= dlc)
                                break;
                        }
                    }
                }
                
                if (dataBytes.Count == 0)
                    dataBytes = Enumerable.Repeat((byte)0, dlc).ToList();
                    
                data = dataBytes.ToArray();
            }
            
            // Определяем тип CAN (CAN или CANFD)
            CANType canType = dlc > 8 ? CANType.CANFD : CANType.CAN;
            
            return new CANMessage
            {
                Timestamp = timestamp,
                ID = id,
                DLC = dlc,
                Data = data,
                Channel = headerIndices.ContainsKey("channel") && headerIndices["channel"] < parts.Length
                    ? parts[headerIndices["channel"]].Trim() : "CAN1",
                CANType = canType
            };
        }

        public static List<CANMessage> ParseASC(string filePath)
        {
            var messages = new List<CANMessage>();
            
            try
            {
                Console.WriteLine($"Парсинг ASC файла: {filePath}");
                
                using var reader = new StreamReader(filePath);
                string? line;
                int lineCount = 0;
                
                while ((line = reader.ReadLine()) != null)
                {
                    lineCount++;
                    
                    // Пропускаем пустые строки и комментарии
                    if (string.IsNullOrWhiteSpace(line) || line.StartsWith("//"))
                        continue;
                    
                    // Проверяем, содержит ли строка CANFD
                    if (!line.Contains("CANFD"))
                        continue;
                    
                    try
                    {
                        // Анализируем структуру строки
                        CANMessage? message = ParseCANFDLine(line);
                        if (message != null)
                        {
                            messages.Add(message);
                            if (messages.Count % 1000 == 0)
                                Console.WriteLine($"Загружено {messages.Count} сообщений...");
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Ошибка парсинга строки ASC (строка {lineCount}): {line}. Ошибка: {ex.Message}");
                    }
                }
                
                Console.WriteLine($"Успешно загружено {messages.Count} сообщений из ASC");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Ошибка чтения ASC файла: {ex.Message}");
            }
            
            return messages;
        }

        private static CANMessage? ParseCANFDLine(string line)
        {
            // Пример строки:
            // "0.039718 CANFD   1 Rx        5B9                                   1 0 D 32 3E 7B 3E 7D 3E 8C 3E 86 3E 86 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00        0    0     3000        0        0        0        0        0"
            
            // Убираем лишние пробелы в начале и конце
            line = line.Trim();
            
            // Разделяем строку на части по пробелам
            var parts = line.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
            
            if (parts.Length < 10)
                return null;
            
            // Проверяем формат
            if (parts[1] != "CANFD")
                return null;
            
            // Парсим timestamp
            if (!double.TryParse(parts[0], NumberStyles.Any, CultureInfo.InvariantCulture, out double timestamp))
                return null;
            
            // Парсим канал
            if (!int.TryParse(parts[2], out int channel))
                channel = 1;
            
            // Направление (Rx/Tx) - parts[3]
            
            // Ищем ID (может быть с разным количеством символов)
            string idStr = parts[4];
            if (string.IsNullOrEmpty(idStr))
                return null;
            
            // Убираем возможные префиксы
            idStr = idStr.Replace("0x", "").Replace("0X", "");
            
            if (!uint.TryParse(idStr, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out uint id))
                return null;
            
            // Теперь нужно найти DLC и данные
            // Ищем индекс, где начинаются данные
            int dataStartIndex = -1;
            int dlc = 8; // по умолчанию
            
            // Проходим по частям, начиная с индекса 5
            for (int i = 5; i < parts.Length; i++)
            {
                string part = parts[i];
                
                // Пропускаем служебные флаги
                if (part == "1" || part == "0" || part == "Rx" || part == "Tx")
                    continue;
                
                // Если это буква D, E, A - это индикатор типа данных
                if (part == "D" || part == "E" || part == "A" || part == "8")
                {
                    // Следующая часть должна быть DLC в hex
                    if (i + 1 < parts.Length)
                    {
                        string dlcStr = parts[i + 1];
                        if (dlcStr.Length <= 2 && IsHexByte(dlcStr))
                        {
                            // Парсим DLC
                            if (int.TryParse(dlcStr, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out dlc))
                            {
                                // Данные начинаются через 2 позиции
                                dataStartIndex = i + 2;
                                break;
                            }
                        }
                        else if (dlcStr.Length <= 2 && int.TryParse(dlcStr, out dlc))
                        {
                            // DLC в десятичном формате
                            dataStartIndex = i + 2;
                            break;
                        }
                    }
                }
                // Если это hex число (1-2 символа) и следующая часть тоже hex число
                else if (part.Length <= 2 && IsHexByte(part))
                {
                    // Проверяем, не является ли это DLC
                    if (i + 1 < parts.Length)
                    {
                        string nextPart = parts[i + 1];
                        if (nextPart.Length <= 2 && IsHexByte(nextPart))
                        {
                            // Первое число - тип, второе - DLC
                            if (int.TryParse(nextPart, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out dlc))
                            {
                                dataStartIndex = i + 2;
                                break;
                            }
                        }
                    }
                }
                
                // Если мы дошли до hex-байта данных (2 символа)
                if (part.Length == 2 && IsHexByte(part))
                {
                    // Это начало данных, DLC не найден, используем значение по умолчанию
                    dataStartIndex = i;
                    break;
                }
            }
            
            if (dataStartIndex == -1 || dataStartIndex >= parts.Length)
                return null;
            
            // Собираем данные
            var dataBytes = new List<byte>();
            
            for (int i = dataStartIndex; i < parts.Length && dataBytes.Count < 64; i++)
            {
                string part = parts[i];
                
                // Если это hex-байт (2 символа)
                if (part.Length == 2 && IsHexByte(part))
                {
                    if (byte.TryParse(part, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out byte byteValue))
                    {
                        dataBytes.Add(byteValue);
                    }
                }
                // Если это длинная строка hex (слипшиеся данные)
                else if (part.Length > 2)
                {
                    // Проверяем, не является ли это служебным полем (например, "3000")
                    if (int.TryParse(part, out int _))
                    {
                        // Это число, не данные
                        break;
                    }
                    
                    // Разделяем слипшиеся hex данные
                    for (int j = 0; j < part.Length; j += 2)
                    {
                        if (j + 1 < part.Length)
                        {
                            string hexPair = part.Substring(j, 2);
                            if (IsHexByte(hexPair))
                            {
                                if (byte.TryParse(hexPair, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out byte byteValue))
                                {
                                    dataBytes.Add(byteValue);
                                    if (dataBytes.Count >= dlc)
                                        break;
                                }
                            }
                        }
                    }
                }
                else
                {
                    // Если встретили не hex данные, останавливаемся
                    break;
                }
                
                // Если собрали достаточно данных по DLC, выходим
                if (dataBytes.Count >= dlc)
                    break;
            }
            
            // Корректируем DLC по фактическому количеству данных
            if (dataBytes.Count > 0)
            {
                dlc = Math.Min(dlc, dataBytes.Count);
            }
            
            // Дополняем нулями если нужно
            while (dataBytes.Count < dlc)
            {
                dataBytes.Add(0);
            }
            
            // Определяем тип CAN
            CANType canType = dlc > 8 ? CANType.CANFD : CANType.CAN;
            
            return new CANMessage
            {
                Timestamp = timestamp,
                ID = id,
                DLC = dlc,
                Data = dataBytes.ToArray(),
                Channel = $"CAN{channel}",
                IsExtended = idStr.Length > 3,
                CANType = canType
            };
        }

        public static List<CANMessage> ParseBLF(string filePath)
        {
            var messages = new List<CANMessage>();
            
            try
            {
                Console.WriteLine("BLF парсинг еще не реализован полностью. Возвращаю пустой список.");
                // TODO: Реализовать полноценный парсинг BLF
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Ошибка чтения BLF файла: {ex.Message}");
            }
            
            return messages;
        }

        private static byte[] ParseHexData(string hexData, int dlc)
        {
            if (string.IsNullOrEmpty(hexData))
                return new byte[dlc];
                
            try
            {
                // Убираем все пробелы и не-hex символы
                hexData = Regex.Replace(hexData, "[^0-9A-Fa-f]", "");
                
                // Если строка пустая, возвращаем нули
                if (string.IsNullOrEmpty(hexData))
                    return new byte[dlc];
                
                // Дополняем до четной длины
                if (hexData.Length % 2 != 0)
                    hexData = "0" + hexData;
                
                // Создаем массив байт
                int byteCount = hexData.Length / 2;
                int actualDlc = Math.Min(dlc, byteCount);
                var data = new byte[actualDlc];
                
                for (int i = 0; i < actualDlc; i++)
                {
                    string byteStr = hexData.Substring(i * 2, 2);
                    if (byte.TryParse(byteStr, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out byte byteValue))
                    {
                        data[i] = byteValue;
                    }
                }
                
                // Если нужно, дополняем нулями
                if (actualDlc < dlc)
                {
                    var paddedData = new byte[dlc];
                    Array.Copy(data, paddedData, actualDlc);
                    return paddedData;
                }
                
                return data;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Ошибка парсинга hex данных: {hexData}. Ошибка: {ex.Message}");
                return new byte[dlc];
            }
        }

        private static bool IsHexByte(string str)
        {
            if (str.Length != 2)
                return false;
                
            foreach (char c in str)
            {
                if (!((c >= '0' && c <= '9') || 
                      (c >= 'A' && c <= 'F') || 
                      (c >= 'a' && c <= 'f')))
                {
                    return false;
                }
            }
            return true;
        }
        
        private static bool IsHexNumber(string str)
        {
            if (string.IsNullOrEmpty(str))
                return false;
            
            str = str.Trim();
            
            // Убираем префикс 0x если есть
            if (str.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                str = str.Substring(2);
            }
            
            // Проверяем, что все символы hex
            foreach (char c in str)
            {
                if (!((c >= '0' && c <= '9') || 
                      (c >= 'A' && c <= 'F') || 
                      (c >= 'a' && c <= 'f')))
                {
                    return false;
                }
            }
            
            return str.Length > 0;
        }
        
        public static LogFormat DetectFormat(string filePath)
        {
            string extension = Path.GetExtension(filePath).ToLower();
            
            if (extension == ".csv")
            {
                try
                {
                    using var reader = new StreamReader(filePath);
                    for (int i = 0; i < 10; i++)
                    {
                        string? line = reader.ReadLine();
                        if (line == null) break;
                        
                        if (line.Contains("PEAK-Converter") || line.Contains("ID/PID (hex)") || 
                            line.StartsWith("Number,Time (ms)"))
                        {
                            Console.WriteLine("Определен формат: CSV (PEAK-Converter)");
                            return LogFormat.CSV;
                        }
                    }
                }
                catch { }
                
                Console.WriteLine("Определен формат: CSV (стандартный)");
                return LogFormat.CSV;
            }
            else if (extension == ".asc")
            {
                try
                {
                    using var reader = new StreamReader(filePath);
                    for (int i = 0; i < 5; i++)
                    {
                        string? line = reader.ReadLine();
                        if (line == null) break;
                        
                        if (line.Contains("CANFD") || line.Contains("base hex") || line.StartsWith("    "))
                        {
                            Console.WriteLine("Определен формат: ASC (Vector)");
                            return LogFormat.ASC;
                        }
                    }
                }
                catch { }
                
                Console.WriteLine("Определен формат: ASC (стандартный)");
                return LogFormat.ASC;
            }
            else if (extension == ".blf")
            {
                Console.WriteLine("Определен формат: BLF");
                return LogFormat.BLF;
            }
            
            Console.WriteLine("Неизвестный формат, используем CSV");
            return LogFormat.CSV;
        }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////

DBCGenerator.cs///////////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using CANalyzer.Core.Models;
using CANalyzer.Core.Analyzers; // ДОБАВЛЕНО: для доступа к SignalDetector

namespace CANalyzer.Core.DBC
{
    public class DBCGenerator
    {
        public static string GenerateDBCFile(List<CANMessage> messages, 
            Dictionary<uint, List<CANSignal>> messageSignals)
        {
            var sb = new StringBuilder();
            
            // Заголовок
            sb.AppendLine("VERSION \"CANalyzer Generated DBC\"");
            sb.AppendLine();
            sb.AppendLine("NS_ :");
            sb.AppendLine("    NS_DESC_");
            sb.AppendLine("    CM_");
            sb.AppendLine("    BA_DEF_");
            sb.AppendLine("    BA_");
            sb.AppendLine("    VAL_");
            sb.AppendLine("    CAT_DEF_");
            sb.AppendLine("    CAT_");
            sb.AppendLine("    FILTER");
            sb.AppendLine("    BA_DEF_DEF_");
            sb.AppendLine("    EV_DATA_");
            sb.AppendLine("    ENVVAR_DATA_");
            sb.AppendLine("    SGTYPE_");
            sb.AppendLine("    SGTYPE_VAL_");
            sb.AppendLine("    BA_DEF_SGTYPE_");
            sb.AppendLine("    BA_SGTYPE_");
            sb.AppendLine("    SIG_TYPE_REF_");
            sb.AppendLine("    VAL_TABLE_");
            sb.AppendLine("    SIG_GROUP_");
            sb.AppendLine("    SIG_VALTYPE_");
            sb.AppendLine("    SIGTYPE_VALTYPE_");
            sb.AppendLine("    BO_TX_BU_");
            sb.AppendLine("    BA_DEF_REL_");
            sb.AppendLine("    BA_REL_");
            sb.AppendLine("    BA_DEF_DEF_REL_");
            sb.AppendLine("    BU_SG_REL_");
            sb.AppendLine("    BU_EV_REL_");
            sb.AppendLine("    BU_BO_REL_");
            sb.AppendLine();
            
            // Сообщения
            foreach (var msgId in messageSignals.Keys)
            {
                var message = messages.FirstOrDefault(m => m.ID == msgId);
                if (message == null) continue;
                
                var signals = messageSignals[msgId];
                int dlc = message.DLC;
                
                sb.AppendLine($"BO_ {msgId} Message_{msgId:X}: {dlc} Vector__XXX");
                
                foreach (var signal in signals)
                {
                    string byteOrder = signal.ByteOrder == ByteOrder.Intel ? "0" : "1";
                    // ИСПРАВЛЕНО: SignalValueType вместо ValueType
                    string valueType = signal.ValueType == SignalValueType.Signed ? "-" : "+";
                    
                    sb.AppendLine($" SG_ {signal.Name} : {signal.StartBit}|{signal.Length}@{byteOrder}{valueType} " +
                                 $"({signal.Factor},{signal.Offset}) [{signal.Minimum}|{signal.Maximum}] \"{signal.Unit}\" Vector__XXX");
                }
                
                sb.AppendLine();
            }
            
            // Таблицы значений для enum сигналов
            foreach (var msgId in messageSignals.Keys)
            {
                var signals = messageSignals[msgId];
                
                foreach (var signal in signals.Where(s => s.SignalType == SignalType.Enum))
                {
                    if (signal.ValueTable.Any())
                    {
                        sb.Append($"VAL_ {msgId} {signal.Name} ");
                        
                        foreach (var entry in signal.ValueTable)
                        {
                            sb.Append($" {entry.Key} \"{entry.Value}\"");
                        }
                        
                        sb.AppendLine(" ;");
                    }
                }
            }
            
            return sb.ToString();
        }
        
        public static void SaveDBCToFile(string dbcContent, string filePath)
        {
            File.WriteAllText(filePath, dbcContent, Encoding.UTF8);
        }
        
        public static void GenerateDBCForAllMessages(List<CANMessage> messages, 
            List<MessageStatistics> statistics, string outputPath)
        {
            var messageSignals = new Dictionary<uint, List<CANSignal>>();
            
            // Детекция сигналов для каждого сообщения
            foreach (var stat in statistics.Where(s => s.Count > 10))
            {
                // ИСПРАВЛЕНО: Доступ к SignalDetector через полное пространство имен
                var signals = SignalDetector.DetectSignals(messages, stat.ID);
                if (signals.Any())
                {
                    messageSignals[stat.ID] = signals;
                }
            }
            
            // Генерация DBC
            string dbcContent = GenerateDBCFile(messages, messageSignals);
            SaveDBCToFile(dbcContent, outputPath);
        }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////

CANalyzer.WPF.csproj//////////////////////////////////////////////////////////////////////////
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net8.0-windows</TargetFramework>
    <Nullable>enable</Nullable>
    <UseWPF>true</UseWPF>
    <ImplicitUsings>enable</ImplicitUsings>
    <Platforms>x64</Platforms>
    <PlatformTarget>x64</PlatformTarget>
    
    <!-- Assembly Info -->
    <AssemblyName>CANalyzer.WPF</AssemblyName>
    <RootNamespace>CANalyzer.WPF</RootNamespace>
    
    <!-- Build Settings -->
    <DebugType>portable</DebugType>
    <DebugSymbols>true</DebugSymbols>
    <Optimize>false</Optimize>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    
    <!-- Assembly Version -->
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
    <FileVersion>1.0.0.0</FileVersion>
    <Version>1.0.0</Version>
    
    <!-- Package Info -->
    <PackageId>CANalyzer</PackageId>
    <Authors>12Volt Development Team</Authors>
    <Company>12Volt</Company>
    <Product>CANalyzer</Product>
    <Description>Advanced CAN Bus Analysis and DBC Generation Tool</Description>
    <Copyright>Copyright © 2024 12Volt</Copyright>
    
    <!-- Warning Level -->
    <WarningLevel>4</WarningLevel>
    <TreatWarningsAsErrors>false</TreatWarningsAsErrors>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <Optimize>false</Optimize>
    <DebugType>full</DebugType>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>portable</DebugType>
  </PropertyGroup>

  <ItemGroup>
    <!-- Core NuGet Packages -->
    <PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Hosting" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Logging" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Logging.Console" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Logging.Debug" Version="8.0.0" />
    
    <!-- WPF and UI Packages -->
    <PackageReference Include="OxyPlot.Wpf" Version="2.1.2" />
    
    <!-- Data and Serialization -->
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
    <PackageReference Include="CsvHelper" Version="30.0.1" />
    
    <!-- Math and Statistics -->
    <PackageReference Include="MathNet.Numerics" Version="5.0.0" />
    
    <!-- Utilities -->
    <PackageReference Include="Serilog" Version="3.1.1" />
    <PackageReference Include="Serilog.Sinks.File" Version="5.0.0" />
    <PackageReference Include="Serilog.Sinks.Console" Version="5.0.1" />
    
    <!-- File and Compression -->
    <PackageReference Include="System.IO.Compression" Version="4.3.0" />
    <PackageReference Include="System.IO.Compression.ZipFile" Version="4.3.0" />
  </ItemGroup>

  <ItemGroup>
    <!-- Project References -->
    <ProjectReference Include="..\CANalyzer.Core\CANalyzer.Core.csproj" />
    <ProjectReference Include="..\CANalyzer.ML\CANalyzer.ML.csproj" />
    <ProjectReference Include="..\CANalyzer.Correlation\CANalyzer.Correlation.csproj" />
    <ProjectReference Include="..\CANalyzer.ReverseEngineering\CANalyzer.ReverseEngineering.csproj" />
  </ItemGroup>

  <ItemGroup>
    <!-- Configuration Files -->
    <None Update="appsettings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>

  <ItemGroup>
    <!-- XAML Files -->
    <Page Update="Views\MainWindow.xaml">
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Update="Views\SettingsWindow.xaml">
      <Generator>MSBuild:Compile</Generator>
    </Page>
    
    <!-- Code-Behind Files -->
    <Compile Update="Views\MainWindow.xaml.cs">
      <DependentUpon>MainWindow.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Compile Update="Views\SettingsWindow.xaml.cs">
      <DependentUpon>SettingsWindow.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
  </ItemGroup>

  <Target Name="PostBuild" AfterTargets="PostBuildEvent">
    <!-- Create necessary directories -->
    <Exec Command="if not exist &quot;$(TargetDir)Logs&quot; mkdir &quot;$(TargetDir)Logs&quot;" />
    <Exec Command="if not exist &quot;$(TargetDir)Exports&quot; mkdir &quot;$(TargetDir)Exports&quot;" />
    <Exec Command="if not exist &quot;$(TargetDir)DBC_Exports&quot; mkdir &quot;$(TargetDir)DBC_Exports&quot;" />
    <Exec Command="if not exist &quot;$(TargetDir)Temp&quot; mkdir &quot;$(TargetDir)Temp&quot;" />
    <Exec Command="if not exist &quot;$(TargetDir)Models&quot; mkdir &quot;$(TargetDir)Models&quot;" />
  </Target>
</Project>
//////////////////////////////////////////////////////////////////////////////////////////////

App.xaml//////////////////////////////////////////////////////////////////////////////////////
<Application x:Class="CANalyzer.WPF.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             Startup="Application_Startup">
</Application>
App.xaml.cs///////////////////////////////////////////////////////////////////////////////////
using System;
using System.IO;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using CANalyzer.WPF.Views;

namespace CANalyzer.WPF
{
    public partial class App : Application
    {
        private static readonly Mutex _appMutex = new Mutex(true, "{12Volt-CANalyzer-2024-APP-ID}");
        private IServiceProvider? _serviceProvider;
        private ILogger<App>? _logger;

        private void Application_Startup(object sender, StartupEventArgs e)
        {
            // Check for single instance
            if (!_appMutex.WaitOne(TimeSpan.Zero, true))
            {
                MessageBox.Show("CANalyzer is already running!", "Application Running", 
                    MessageBoxButton.OK, MessageBoxImage.Information);
                Current.Shutdown();
                return;
            }

            try
            {
                // Setup global exception handling
                SetupExceptionHandling();

                // Configure services
                _serviceProvider = ConfigureServices();

                // Create necessary directories
                CreateApplicationDirectories();

                // Show main window
                var mainWindow = _serviceProvider.GetRequiredService<MainWindow>();
                mainWindow.Show();

                _logger?.LogInformation("Application started successfully");
            }
            catch (Exception ex)
            {
                HandleFatalStartupError(ex);
            }
        }

        protected override void OnExit(ExitEventArgs e)
        {
            try
            {
                _logger?.LogInformation("Application shutting down...");

                // Clean up temp files
                CleanupTempFiles();

                _logger?.LogInformation("Application shutdown complete");
            }
            catch (Exception ex)
            {
                LogError("Error during shutdown", ex);
            }
            finally
            {
                // Ensure mutex is released
                try { _appMutex?.Close(); } catch { }
                
                base.OnExit(e);
            }
        }

        private IServiceProvider ConfigureServices()
        {
            var services = new ServiceCollection();

            // Configuration
            var configuration = new ConfigurationBuilder()
                .SetBasePath(AppDomain.CurrentDomain.BaseDirectory)
                .AddJsonFile("appsettings.json", optional: true, reloadOnChange: true)
                .Build();
            
            services.AddSingleton<IConfiguration>(configuration);

            // Logging
            services.AddLogging(logging =>
            {
                logging.ClearProviders();
                logging.AddConsole();
                logging.AddDebug();
                logging.AddConfiguration(configuration.GetSection("Logging"));
            });

            // Windows
            services.AddSingleton<MainWindow>();
            services.AddTransient<SettingsWindow>();

            // Build and return service provider
            var serviceProvider = services.BuildServiceProvider();
            
            // Get logger instance
            _logger = serviceProvider.GetRequiredService<ILogger<App>>();
            
            return serviceProvider;
        }

        private void SetupExceptionHandling()
        {
            // Global WPF exceptions
            DispatcherUnhandledException += (sender, args) =>
            {
                LogError("Dispatcher Unhandled Exception", args.Exception);
                args.Handled = true;
                ShowErrorDialog("UI Error", 
                    $"An error occurred in the user interface:\n\n{args.Exception.Message}", 
                    args.Exception);
            };

            // Global AppDomain exceptions
            AppDomain.CurrentDomain.UnhandledException += (sender, args) =>
            {
                var exception = args.ExceptionObject as Exception;
                LogError("AppDomain Unhandled Exception", exception);
                ShowFatalErrorDialog(exception);
            };

            // Task scheduler exceptions
            TaskScheduler.UnobservedTaskException += (sender, args) =>
            {
                LogError("Unobserved Task Exception", args.Exception);
                args.SetObserved();
            };
        }

        private void CreateApplicationDirectories()
        {
            var basePath = AppDomain.CurrentDomain.BaseDirectory;
            var directories = new[]
            {
                Path.Combine(basePath, "Logs"),
                Path.Combine(basePath, "Exports"),
                Path.Combine(basePath, "DBC_Exports"),
                Path.Combine(basePath, "Temp"),
                Path.Combine(basePath, "Models")
            };

            foreach (var directory in directories)
            {
                if (!Directory.Exists(directory))
                {
                    Directory.CreateDirectory(directory);
                    Console.WriteLine($"Created directory: {directory}");
                }
            }
        }

        private void CleanupTempFiles()
        {
            try
            {
                var tempPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Temp");
                if (Directory.Exists(tempPath))
                {
                    var files = Directory.GetFiles(tempPath, "*.*", SearchOption.AllDirectories);
                    foreach (var file in files)
                    {
                        try
                        {
                            File.Delete(file);
                        }
                        catch { /* Ignore delete errors */ }
                    }
                    Console.WriteLine("Cleaned up temp files");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error cleaning up temp files: {ex.Message}");
            }
        }

        private void LogError(string context, Exception? exception)
        {
            try
            {
                string logPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Logs", "error.log");
                string logMessage = $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {context}\n" +
                                   $"Message: {exception?.Message}\n" +
                                   $"Type: {exception?.GetType().Name}\n" +
                                   $"Stack Trace: {exception?.StackTrace}\n" +
                                   "----------------------------------------\n";

                File.AppendAllText(logPath, logMessage);
            }
            catch { /* Ignore logging errors */ }
        }

        private void ShowErrorDialog(string title, string message, Exception? exception = null)
        {
            Dispatcher.Invoke(() =>
            {
                var fullMessage = message;
                if (exception != null)
                {
                    fullMessage += $"\n\nTechnical Details:\n{exception.Message}";
                }

                MessageBox.Show(fullMessage, title, 
                    MessageBoxButton.OK, MessageBoxImage.Error);
            });
        }

        private void ShowFatalErrorDialog(Exception? exception)
        {
            Dispatcher.Invoke(() =>
            {
                var message = $"A fatal error has occurred and the application must close.\n\n" +
                            $"Error: {exception?.Message}\n\n" +
                            "Please check the error log for more details.";

                MessageBox.Show(message, "Fatal Error", 
                    MessageBoxButton.OK, MessageBoxImage.Error);

                Current.Shutdown(1);
            });
        }

        private void HandleFatalStartupError(Exception exception)
        {
            string errorMessage = $"Failed to start CANalyzer:\n\n{exception.Message}\n\n" +
                                "Please check the following:\n" +
                                "1. You have .NET 8.0 Runtime installed\n" +
                                "2. Required dependencies are available\n" +
                                "3. The application has necessary permissions";

            MessageBox.Show(errorMessage, "Startup Error", 
                MessageBoxButton.OK, MessageBoxImage.Error);

            LogError("Fatal Startup Error", exception);
            Current.Shutdown(1);
        }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////

appsettings.json//////////////////////////////////////////////////////////////////////////////
{
  "AppSettings": {
    "AppName": "CANalyzer",
    "Version": "1.0.0",
    "DefaultLogPath": "C:\\CAN_Logs",
    "AutoSaveInterval": 300,
    "EnableBackgroundAnalysis": true,
    "MaxSignalCountPerMessage": 20
  },
  "AnalysisSettings": {
    "MinMessageCount": 10,
    "SignalDetectionThreshold": 0.7,
    "MaxSignalLength": 32,
    "EnableMLClassification": true,
    "EnableCorrelationAnalysis": true,
    "CorrelationThreshold": 0.7
  },
  "UISettings": {
    "Theme": "Dark",
    "UpdateInterval": 1000,
    "ShowRawData": true,
    "ShowDecodedSignals": true,
    "ShowCorrelations": true,
    "MaxPointsInPlot": 1000
  },
  "MLSettings": {
    "ModelPath": "Models\\signal_classifier.model",
    "TrainingEpochs": 100,
    "BatchSize": 32,
    "LearningRate": 0.001,
    "UsePretrained": false
  }
}
//////////////////////////////////////////////////////////////////////////////////////////////

MainWindow.xaml///////////////////////////////////////////////////////////////////////////////
<Window x:Class="CANalyzer.WPF.Views.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:oxy="http://oxyplot.org/wpf"
        xmlns:local="clr-namespace:CANalyzer.WPF.Views"
        mc:Ignorable="d"
        Title="CANalyzer - Advanced CAN Bus Analyzer" 
        Height="900" Width="1600"
        WindowStartupLocation="CenterScreen">
    
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>
        
        <!-- Toolbar -->
        <ToolBar Grid.Row="0" Margin="5">
            <Button x:Name="btnLoadLog" Content="📁 Load CAN Log" Click="BtnLoadLog_Click" ToolTip="Load CAN log file"/>
            <Separator/>
            <Button x:Name="btnAnalyze" Content="🔍 Analyze" Click="BtnAnalyze_Click" ToolTip="Start analysis"/>
            <Button x:Name="btnGenerateDBC" Content="📄 Generate DBC" Click="BtnGenerateDBC_Click" ToolTip="Generate DBC file"/>
            <Separator/>
            <Button x:Name="btnRunPipeline" Content="🔄 Reverse Engineering" Click="BtnRunPipeline_Click" ToolTip="Run reverse engineering pipeline"/>
            <Separator/>
            <Button x:Name="btnExport" Content="💾 Export Results" Click="BtnExport_Click"/>
            <Button x:Name="btnSettings" Content="⚙ Settings" Click="BtnSettings_Click"/>
        </ToolBar>
        
        <!-- Main Content Area with 4 windows -->
        <TabControl Grid.Row="1" Margin="5">
            <TabItem Header="📊 Raw Data">
                <Grid>
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="*"/>
                    </Grid.RowDefinitions>
                    
                    <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="5">
                        <TextBlock Text="File: " FontWeight="Bold" VerticalAlignment="Center"/>
                        <TextBlock x:Name="txtFileName" Text="No file loaded" Margin="10,0" VerticalAlignment="Center"/>
                        <TextBlock Text="Messages: " FontWeight="Bold" VerticalAlignment="Center" Margin="20,0,0,0"/>
                        <TextBlock x:Name="txtMessageCount" Text="0" VerticalAlignment="Center"/>
                    </StackPanel>
                    
                    <DataGrid x:Name="dgRawData" Grid.Row="1" Margin="5"
                             AutoGenerateColumns="False" 
                             IsReadOnly="True"
                             CanUserAddRows="False"
                             CanUserDeleteRows="False"
                             SelectionMode="Single"
                             ScrollViewer.CanContentScroll="True"
                             ScrollViewer.VerticalScrollBarVisibility="Auto">
                        <DataGrid.Columns>
                            <DataGridTextColumn Header="Time" Binding="{Binding Timestamp}" Width="100"/>
                            <DataGridTextColumn Header="Channel" Binding="{Binding Channel}" Width="70"/>
                            <DataGridTextColumn Header="ID" Binding="{Binding ID}" Width="70"/>
                            <DataGridTextColumn Header="DLC" Binding="{Binding DLC}" Width="50"/>
                            <DataGridTextColumn Header="Type" Binding="{Binding Type}" Width="70"/>
                            <DataGridTextColumn Header="Data" Binding="{Binding DataHex}" Width="Auto" MinWidth="200"/>
                            <DataGridTextColumn Header="Signals" Binding="{Binding SignalsCount}" Width="70"/>
                        </DataGrid.Columns>
                    </DataGrid>
                </Grid>
            </TabItem>
            
            <TabItem Header="📈 Decoded Signals">
                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="300"/>
                        <ColumnDefinition Width="*"/>
                    </Grid.ColumnDefinitions>
                    
                    <!-- Signal List -->
                    <ListView x:Name="lvSignals" Grid.Column="0" Margin="5"
                             SelectionChanged="LvSignals_SelectionChanged">
                        <ListView.View>
                            <GridView>
                                <GridViewColumn Header="Name" DisplayMemberBinding="{Binding Name}" Width="150"/>
                                <GridViewColumn Header="Type" DisplayMemberBinding="{Binding SignalType}" Width="80"/>
                                <GridViewColumn Header="Message" DisplayMemberBinding="{Binding MessageID, StringFormat=X}" Width="70"/>
                            </GridView>
                        </ListView.View>
                    </ListView>
                    
                    <!-- Signal Details and Plot -->
                    <Grid Grid.Column="1" Margin="5">
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="*"/>
                        </Grid.RowDefinitions>
                        
                        <GroupBox Grid.Row="0" Header="Signal Details" Margin="5">
                            <StackPanel>
                                <Grid>
                                    <Grid.ColumnDefinitions>
                                        <ColumnDefinition Width="Auto"/>
                                        <ColumnDefinition Width="*"/>
                                        <ColumnDefinition Width="Auto"/>
                                        <ColumnDefinition Width="*"/>
                                    </Grid.ColumnDefinitions>
                                    <Grid.RowDefinitions>
                                        <RowDefinition Height="Auto"/>
                                        <RowDefinition Height="Auto"/>
                                        <RowDefinition Height="Auto"/>
                                    </Grid.RowDefinitions>
                                    
                                    <TextBlock Grid.Row="0" Grid.Column="0" Text="Name:" FontWeight="Bold" Margin="5"/>
                                    <TextBlock x:Name="txtSignalName" Grid.Row="0" Grid.Column="1" Margin="5"/>
                                    
                                    <TextBlock Grid.Row="0" Grid.Column="2" Text="Range:" FontWeight="Bold" Margin="5"/>
                                    <TextBlock x:Name="txtSignalRange" Grid.Row="0" Grid.Column="3" Margin="5"/>
                                    
                                    <TextBlock Grid.Row="1" Grid.Column="0" Text="Bits:" FontWeight="Bold" Margin="5"/>
                                    <TextBlock x:Name="txtSignalBits" Grid.Row="1" Grid.Column="1" Margin="5"/>
                                    
                                    <TextBlock Grid.Row="1" Grid.Column="2" Text="Unit:" FontWeight="Bold" Margin="5"/>
                                    <TextBlock x:Name="txtSignalUnit" Grid.Row="1" Grid.Column="3" Margin="5"/>
                                    
                                    <TextBlock Grid.Row="2" Grid.Column="0" Text="Scaling:" FontWeight="Bold" Margin="5"/>
                                    <TextBlock x:Name="txtSignalScaling" Grid.Row="2" Grid.Column="1" Margin="5"/>
                                    
                                    <TextBlock Grid.Row="2" Grid.Column="2" Text="Classification:" FontWeight="Bold" Margin="5"/>
                                    <TextBlock x:Name="txtSignalClassification" Grid.Row="2" Grid.Column="3" Margin="5"/>
                                </Grid>
                            </StackPanel>
                        </GroupBox>
                        
                        <!-- Signal Plot -->
                        <GroupBox Grid.Row="1" Header="Signal Visualization" Margin="5">
                            <oxy:PlotView x:Name="signalPlot" Model="{Binding SignalPlotModel}"/>
                        </GroupBox>
                    </Grid>
                </Grid>
            </TabItem>
            
            <TabItem Header="🔗 Correlations">
                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="300"/>
                        <ColumnDefinition Width="*"/>
                    </Grid.ColumnDefinitions>
                    
                    <!-- Correlation List -->
                    <ListView x:Name="lvCorrelations" Grid.Column="0" Margin="5"
                             SelectionChanged="LvCorrelations_SelectionChanged">
                        <ListView.View>
                            <GridView>
                                <GridViewColumn Header="Signal A" DisplayMemberBinding="{Binding SignalAName}" Width="120"/>
                                <GridViewColumn Header="Signal B" DisplayMemberBinding="{Binding SignalBName}" Width="120"/>
                                <GridViewColumn Header="Correlation" DisplayMemberBinding="{Binding Correlation, StringFormat=F3}" Width="80"/>
                            </GridView>
                        </ListView.View>
                    </ListView>
                    
                    <!-- Correlation Details and Plot -->
                    <Grid Grid.Column="1" Margin="5">
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="*"/>
                        </Grid.RowDefinitions>
                        
                        <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="5">
                            <TextBlock Text="Selected Correlation: " FontWeight="Bold"/>
                            <TextBlock x:Name="txtCorrelationDetails" Margin="10,0"/>
                        </StackPanel>
                        
                        <!-- Correlation Plot -->
                        <GroupBox Grid.Row="1" Header="Correlation Visualization" Margin="5">
                            <oxy:PlotView x:Name="correlationPlot" Model="{Binding CorrelationPlotModel}"/>
                        </GroupBox>
                    </Grid>
                </Grid>
            </TabItem>
            
            <!-- Новая вкладка для Reverse Engineering -->
            <TabItem Header="🔬 Reverse Engineering">
                <Grid>
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="*"/>
                    </Grid.RowDefinitions>
                    
                    <!-- Toolbar для Reverse Engineering -->
                    <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="5">
                        <Button x:Name="btnPreProcess" Content="Pre-Process" Click="BtnPreProcess_Click" Margin="5" Width="100"/>
                        <Button x:Name="btnLexicalAnalysis" Content="Lexical Analysis" Click="BtnLexicalAnalysis_Click" Margin="5" Width="100"/>
                        <Button x:Name="btnSemanticAnalysis" Content="Semantic Analysis" Click="BtnSemanticAnalysis_Click" Margin="5" Width="100"/>
                        <Button x:Name="btnExportPipeline" Content="Export Results" Click="BtnExportPipeline_Click" Margin="5" Width="100"/>
                    </StackPanel>
                    
                    <!-- Основное содержимое -->
                    <Grid Grid.Row="1">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="300"/>
                            <ColumnDefinition Width="*"/>
                            <ColumnDefinition Width="300"/>
                        </Grid.ColumnDefinitions>
                        
                        <!-- Левая колонка: ArbIDs и Сигналы -->
                        <Grid Grid.Column="0">
                            <Grid.RowDefinitions>
                                <RowDefinition Height="*"/>
                                <RowDefinition Height="*"/>
                            </Grid.RowDefinitions>
                            
                            <!-- ArbIDs -->
                            <GroupBox Grid.Row="0" Header="ArbIDs" Margin="5">
                                <DataGrid x:Name="dgPipelineArbIDs" AutoGenerateColumns="False" IsReadOnly="True"
                                         SelectionMode="Single" CanUserAddRows="False" CanUserDeleteRows="False">
                                    <DataGrid.Columns>
                                        <DataGridTextColumn Header="ID" Binding="{Binding ID}" Width="60"/>
                                        <DataGridTextColumn Header="Count" Binding="{Binding MessageCount}" Width="60"/>
                                        <DataGridTextColumn Header="Freq" Binding="{Binding Frequency}" Width="60"/>
                                        <DataGridTextColumn Header="DLC" Binding="{Binding DLC}" Width="40"/>
                                    </DataGrid.Columns>
                                </DataGrid>
                            </GroupBox>
                            
                            <!-- Сигналы -->
                            <GroupBox Grid.Row="1" Header="Detected Signals" Margin="5">
                                <ListView x:Name="lvPipelineSignals" SelectionChanged="LvPipelineSignals_SelectionChanged">
                                    <ListView.View>
                                        <GridView>
                                            <GridViewColumn Header="Name" DisplayMemberBinding="{Binding Name}" Width="120"/>
                                            <GridViewColumn Header="Byte" DisplayMemberBinding="{Binding Byte}" Width="40"/>
                                            <GridViewColumn Header="Type" DisplayMemberBinding="{Binding Type}" Width="60"/>
                                        </GridView>
                                    </ListView.View>
                                </ListView>
                            </GroupBox>
                        </Grid>
                        
                        <!-- Центральная колонка: Графики -->
                        <Grid Grid.Column="1">
                            <Grid.RowDefinitions>
                                <RowDefinition Height="*"/>
                                <RowDefinition Height="*"/>
                            </Grid.RowDefinitions>
                            
                            <!-- Pipeline Signal Plot -->
                            <GroupBox Grid.Row="0" Header="Signal Plot" Margin="5">
                                <oxy:PlotView x:Name="pipelinePlot" Model="{Binding PipelinePlotModel}"/>
                            </GroupBox>
                            
                            <!-- Cluster Plot -->
                            <GroupBox Grid.Row="1" Header="Cluster Plot" Margin="5">
                                <oxy:PlotView x:Name="clusterPlot" Model="{Binding ClusterPlotModel}"/>
                            </GroupBox>
                        </Grid>
                        
                        <!-- Правая колонка: Детали и Кластеры -->
                        <Grid Grid.Column="2">
                            <Grid.RowDefinitions>
                                <RowDefinition Height="*"/>
                                <RowDefinition Height="*"/>
                            </Grid.RowDefinitions>
                            
                            <!-- Детали сигнала -->
                            <GroupBox Grid.Row="0" Header="Signal Details" Margin="5">
                                <StackPanel Margin="5">
                                    <Grid>
                                        <Grid.RowDefinitions>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                        </Grid.RowDefinitions>
                                        
                                        <StackPanel Grid.Row="0" Orientation="Horizontal">
                                            <TextBlock Text="ArbID:" FontWeight="Bold" Width="100"/>
                                            <TextBlock x:Name="txtPipelineArbID" Margin="5,0"/>
                                        </StackPanel>
                                        
                                        <StackPanel Grid.Row="1" Orientation="Horizontal">
                                            <TextBlock Text="Byte:" FontWeight="Bold" Width="100"/>
                                            <TextBlock x:Name="txtPipelineByte" Margin="5,0"/>
                                        </StackPanel>
                                        
                                        <StackPanel Grid.Row="2" Orientation="Horizontal">
                                            <TextBlock Text="Range:" FontWeight="Bold" Width="100"/>
                                            <TextBlock x:Name="txtPipelineRange" Margin="5,0"/>
                                        </StackPanel>
                                        
                                        <StackPanel Grid.Row="3" Orientation="Horizontal">
                                            <TextBlock Text="Unique Values:" FontWeight="Bold" Width="100"/>
                                            <TextBlock x:Name="txtPipelineUnique" Margin="5,0"/>
                                        </StackPanel>
                                        
                                        <StackPanel Grid.Row="4" Orientation="Horizontal">
                                            <TextBlock Text="Mean:" FontWeight="Bold" Width="100"/>
                                            <TextBlock x:Name="txtPipelineMean" Margin="5,0"/>
                                        </StackPanel>
                                        
                                        <StackPanel Grid.Row="5" Orientation="Horizontal">
                                            <TextBlock Text="Std Dev:" FontWeight="Bold" Width="100"/>
                                            <TextBlock x:Name="txtPipelineStdDev" Margin="5,0"/>
                                        </StackPanel>
                                    </Grid>
                                </StackPanel>
                            </GroupBox>
                            
                            <!-- Кластеры -->
                            <GroupBox Grid.Row="1" Header="Clusters" Margin="5">
                                <StackPanel>
                                    <ListView x:Name="lvClusters" SelectionChanged="LvClusters_SelectionChanged" Height="150">
                                        <ListView.View>
                                            <GridView>
                                                <GridViewColumn Header="Cluster" DisplayMemberBinding="{Binding ClusterId}" Width="60"/>
                                                <GridViewColumn Header="Signals" DisplayMemberBinding="{Binding SignalCount}" Width="60"/>
                                                <GridViewColumn Header="Sample" DisplayMemberBinding="{Binding SignalNames}" Width="150"/>
                                            </GridView>
                                        </ListView.View>
                                    </ListView>
                                    <TextBlock x:Name="txtClusterInfo" Margin="5" FontWeight="Bold"/>
                                </StackPanel>
                            </GroupBox>
                        </Grid>
                    </Grid>
                </Grid>
            </TabItem>
        </TabControl>
        
        <!-- Status Bar -->
        <StatusBar Grid.Row="2" Margin="5">
            <StatusBarItem>
                <TextBlock x:Name="txtStatus" Text="Ready"/>
            </StatusBarItem>
            <Separator/>
            <StatusBarItem>
                <ProgressBar x:Name="progressBar" Width="200" Height="20" IsIndeterminate="False"/>
            </StatusBarItem>
            <Separator/>
            <StatusBarItem>
                <TextBlock x:Name="txtProgress" Text=""/>
            </StatusBarItem>
        </StatusBar>
    </Grid>
</Window>
//////////////////////////////////////////////////////////////////////////////////////////////

MainWindow.xaml.cs////////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using Microsoft.Win32;
using OxyPlot;
using OxyPlot.Series;
using OxyPlot.Axes;
using CANalyzer.Core.Models;
using CANalyzer.Core.Parsers;
using CANalyzer.Core.Analyzers;
using CANalyzer.Core.DBC;
using CANalyzer.ML.NeuralNetworks;
using CANalyzer.Correlation.Analyzers;
using CANalyzer.ReverseEngineering.Analyzers;
using CANalyzer.ReverseEngineering.Models;

namespace CANalyzer.WPF.Views
{
    public partial class MainWindow : Window
    {
        // Original analysis fields
        private List<CANMessage> _messages = new List<CANMessage>();
        private List<MessageStatistics> _statistics = new List<MessageStatistics>();
        private Dictionary<uint, List<CANSignal>> _detectedSignals = new Dictionary<uint, List<CANSignal>>();
        private List<CANSignal> _allSignals = new List<CANSignal>();
        private List<CorrelationResult> _correlations = new List<CorrelationResult>();
        private BackgroundWorker? _analysisWorker;
        private volatile bool _analysisCancelled = false;
        
        // Reverse Engineering pipeline fields
        private CANPreProcessor? _preProcessor;
        private CANLexicalAnalyzer? _lexicalAnalyzer;
        private CANSemanticAnalyzer? _semanticAnalyzer;
        private List<Signal> _pipelineSignals = new List<Signal>();
        
        // Plot models
        public PlotModel SignalPlotModel { get; private set; }
        public PlotModel CorrelationPlotModel { get; private set; }
        public PlotModel PipelinePlotModel { get; private set; }
        public PlotModel ClusterPlotModel { get; private set; }
        
        public MainWindow()
        {
            InitializeComponent();
            
            // Initialize plot models
            SignalPlotModel = new PlotModel { Title = "Signal Values" };
            CorrelationPlotModel = new PlotModel { Title = "Signal Correlation" };
            PipelinePlotModel = new PlotModel { Title = "Pipeline Signal" };
            ClusterPlotModel = new PlotModel { Title = "Cluster Visualization" };
            
            DataContext = this;
            
            // Initialize BackgroundWorker for asynchronous analysis
            InitializeBackgroundWorker();
            
            // Initialize reverse engineering analyzers
            InitializeReverseEngineeringAnalyzers();
        }
        
        private void InitializeBackgroundWorker()
        {
            _analysisWorker = new BackgroundWorker();
            _analysisWorker.WorkerReportsProgress = true;
            _analysisWorker.WorkerSupportsCancellation = true;
            
            _analysisWorker.DoWork += AnalysisWorker_DoWork;
            _analysisWorker.ProgressChanged += AnalysisWorker_ProgressChanged;
            _analysisWorker.RunWorkerCompleted += AnalysisWorker_RunWorkerCompleted;
        }
        
        private void InitializeReverseEngineeringAnalyzers()
        {
            _preProcessor = new CANPreProcessor();
            _lexicalAnalyzer = new CANLexicalAnalyzer();
            _semanticAnalyzer = new CANSemanticAnalyzer();
        }
        
        #region Original Analysis Methods
        
        private async void BtnLoadLog_Click(object sender, RoutedEventArgs e)
        {
            var openFileDialog = new OpenFileDialog
            {
                Filter = "CAN Log Files (*.csv;*.asc;*.blf)|*.csv;*.asc;*.blf|All Files (*.*)|*.*",
                Title = "Select CAN Log File"
            };
        
            if (openFileDialog.ShowDialog() == true)
            {
                try
                {
                    txtStatus.Text = "Loading log file...";
                    progressBar.IsIndeterminate = true;
                    
                    string filePath = openFileDialog.FileName;
                    txtFileName.Text = System.IO.Path.GetFileName(filePath);
                    
                    // Determine file format
                    LogFormat format = DetermineLogFormat(filePath);
                    
                    // Load log using LogParser - используем Task.Run для асинхронной загрузки
                    _messages = await Task.Run(() => LogParser.Parse(filePath, format));
                    
                    // Check if data is loaded
                    if (_messages == null || _messages.Count == 0)
                    {
                        MessageBox.Show("No messages found in the log file.", "Warning", 
                            MessageBoxButton.OK, MessageBoxImage.Warning);
                        txtStatus.Text = "No messages loaded";
                        return;
                    }
                    
                    // Remove possible duplicates
                    _messages = RemoveDuplicateMessages(_messages);
            
                    MessageBox.Show($"Successfully loaded {_messages.Count} messages", "Success", 
                        MessageBoxButton.OK, MessageBoxImage.Information);
            
                    txtMessageCount.Text = _messages.Count.ToString();
                    UpdateRawDataGrid();
            
                    txtStatus.Text = $"Loaded {_messages.Count} messages from {txtFileName.Text}";
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"Error loading file: {ex.Message}\n\nStack trace: {ex.StackTrace}", 
                        "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                    txtStatus.Text = "Error loading file";
                }
                finally
                {
                    progressBar.IsIndeterminate = false;
                }
            }
        }
        
        private List<CANMessage> RemoveDuplicateMessages(List<CANMessage> messages)
        {
            var uniqueMessages = new Dictionary<string, CANMessage>();
            
            foreach (var msg in messages)
            {
                // Create unique key: timestamp + ID + first 8 bytes of data
                string key = $"{msg.Timestamp:F6}_{msg.ID:X}_{BitConverter.ToString(msg.Data, 0, Math.Min(8, msg.Data.Length))}";
                
                if (!uniqueMessages.ContainsKey(key))
                {
                    uniqueMessages[key] = msg;
                }
                else
                {
                    Debug.WriteLine($"Found duplicate message: {key}");
                }
            }
            
            return uniqueMessages.Values.ToList();
        }
        
        private LogFormat DetermineLogFormat(string filePath)
        {
            string extension = System.IO.Path.GetExtension(filePath).ToLower();
            
            return extension switch
            {
                ".csv" => LogFormat.CSV,
                ".asc" => LogFormat.ASC,
                ".blf" => LogFormat.BLF,
                _ => LogFormat.CSV
            };
        }
        
        private void BtnAnalyze_Click(object sender, RoutedEventArgs e)
        {
            if (_messages.Count == 0)
            {
                MessageBox.Show("Please load a log file first.", "Warning", 
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            
            if (_analysisWorker?.IsBusy == true)
            {
                var result = MessageBox.Show("Analysis is already running. Do you want to cancel?", 
                    "Analysis in Progress", MessageBoxButton.YesNo, MessageBoxImage.Question);
                
                if (result == MessageBoxResult.Yes)
                {
                    _analysisCancelled = true;
                    _analysisWorker?.CancelAsync();
                }
                return;
            }
            
            try
            {
                _analysisCancelled = false;
                
                // Reset previous results
                _statistics.Clear();
                _detectedSignals.Clear();
                _allSignals.Clear();
                _correlations.Clear();
                
                // Update UI
                btnAnalyze.IsEnabled = false;
                btnAnalyze.Content = "Analyzing...";
                progressBar.IsIndeterminate = false;
                progressBar.Value = 0;
                txtStatus.Text = "Starting analysis...";
                
                // Start background analysis
                var analysisParams = new AnalysisParameters
                {
                    Messages = _messages,
                    MessageCount = _messages.Count
                };
                
                _analysisWorker?.RunWorkerAsync(analysisParams);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error starting analysis: {ex.Message}", "Error", 
                    MessageBoxButton.OK, MessageBoxImage.Error);
                ResetAnalysisUI();
            }
        }
        
        private void AnalysisWorker_DoWork(object? sender, DoWorkEventArgs e)
        {
            try
            {
                var worker = sender as BackgroundWorker;
                var parameters = e.Argument as AnalysisParameters;
                
                if (parameters == null || parameters.Messages == null)
                {
                    e.Result = "Invalid analysis parameters";
                    return;
                }
                
                var messages = parameters.Messages;
                int totalSteps = 6;
                int currentStep = 0;
                
                // Check for cancellation
                if (_analysisCancelled || worker?.CancellationPending == true)
                {
                    e.Cancel = true;
                    return;
                }
                
                // Step 1: Statistical analysis
                worker?.ReportProgress(0, "Calculating message statistics...");
                var statistics = StatisticalAnalyzer.CalculateStatistics(messages);
                currentStep++;
                worker?.ReportProgress((currentStep * 100) / totalSteps, 
                    $"Calculated statistics for {statistics.Count} message IDs");
                
                // Step 2: Signal detection
                if (_analysisCancelled || worker?.CancellationPending == true)
                {
                    e.Cancel = true;
                    return;
                }
                
                worker?.ReportProgress((currentStep * 100) / totalSteps, 
                    "Detecting signals...");
                
                var detectedSignals = new Dictionary<uint, List<CANSignal>>();
                var allSignals = new List<CANSignal>();
                
                // Analyze only messages with sufficient data
                var messagesToAnalyze = statistics
                    .Where(s => s.Count > 10)
                    .OrderByDescending(s => s.Count)
                    .Take(50) // Limit for performance
                    .ToList();
                
                int processedMessages = 0;
                int totalMessagesToAnalyze = messagesToAnalyze.Count;
                
                foreach (var stat in messagesToAnalyze)
                {
                    // Check for cancellation
                    if (_analysisCancelled || worker?.CancellationPending == true)
                    {
                        e.Cancel = true;
                        return;
                    }
                    
                    try
                    {
                        var signals = SignalDetector.DetectSignals(messages, stat.ID);
                        if (signals.Any())
                        {
                            detectedSignals[stat.ID] = signals;
                            allSignals.AddRange(signals);
                            
                            // Add raw values for each signal
                            var messageGroup = messages.Where(m => m.ID == stat.ID).ToList();
                            foreach (var signal in signals)
                            {
                                foreach (var msg in messageGroup.Take(100)) // Limit number of values
                                {
                                    uint rawValue = ExtractBits(msg.Data, signal.StartBit, signal.Length);
                                    signal.RawValues.Add(rawValue);
                                    signal.PhysicalValues.Add(signal.GetPhysicalValue(rawValue));
                                }
                            }
                        }
                        
                        processedMessages++;
                        int progress = 20 + (processedMessages * 40 / Math.Max(1, totalMessagesToAnalyze));
                        worker?.ReportProgress(progress, 
                            $"Analyzed {processedMessages}/{totalMessagesToAnalyze} messages...");
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine($"Error detecting signals for ID 0x{stat.ID:X}: {ex.Message}");
                        // Continue analysis of other messages
                    }
                }
                
                currentStep = 3;
                worker?.ReportProgress(60, $"Detected {allSignals.Count} signals");
                
                // Step 3: ML classification
                if (_analysisCancelled || worker?.CancellationPending == true)
                {
                    e.Cancel = true;
                    return;
                }
                
                if (allSignals.Any())
                {
                    worker?.ReportProgress(60, "Classifying signals using ML...");
                    
                    var classifier = new SignalClassifier();
                    int classifiedSignals = 0;
                    
                    foreach (var signal in allSignals.Where(s => s.RawValues.Count > 5))
                    {
                        // Check for cancellation
                        if (_analysisCancelled || worker?.CancellationPending == true)
                        {
                            e.Cancel = true;
                            return;
                        }
                        
                        try
                        {
                            signal.Classification = classifier.ClassifySignal(signal);
                            classifiedSignals++;
                            
                            if (classifiedSignals % 10 == 0)
                            {
                                worker?.ReportProgress(70, 
                                    $"Classified {classifiedSignals}/{allSignals.Count} signals...");
                            }
                        }
                        catch (Exception ex)
                        {
                            Debug.WriteLine($"Error classifying signal {signal.Name}: {ex.Message}");
                        }
                    }
                    
                    currentStep = 4;
                    worker?.ReportProgress(75, 
                        $"Classified {classifiedSignals} signals using ML");
                }
                
                // Step 4: Correlation analysis
                if (_analysisCancelled || worker?.CancellationPending == true)
                {
                    e.Cancel = true;
                    return;
                }
                
                if (allSignals.Count > 1)
                {
                    worker?.ReportProgress(75, "Analyzing signal correlations...");
                    
                    try
                    {
                        var correlationAnalyzer = new CorrelationAnalyzer();
                        var correlations = correlationAnalyzer.AnalyzeCorrelations(allSignals);
                        
                        currentStep = 5;
                        worker?.ReportProgress(85, 
                            $"Found {correlations.Count} significant correlations");
                        
                        // Step 5: Prepare results
                        if (_analysisCancelled || worker?.CancellationPending == true)
                        {
                            e.Cancel = true;
                            return;
                        }
                        
                        worker?.ReportProgress(90, "Preparing results...");
                        
                        // Return results
                        var results = new AnalysisResults
                        {
                            Statistics = statistics,
                            DetectedSignals = detectedSignals,
                            AllSignals = allSignals,
                            Correlations = correlations
                        };
                        
                        e.Result = results;
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine($"Error in correlation analysis: {ex.Message}");
                        e.Result = new AnalysisResults
                        {
                            Statistics = statistics,
                            DetectedSignals = detectedSignals,
                            AllSignals = allSignals,
                            Correlations = new List<CorrelationResult>()
                        };
                    }
                }
                else
                {
                    e.Result = new AnalysisResults
                    {
                        Statistics = statistics,
                        DetectedSignals = detectedSignals,
                        AllSignals = allSignals,
                        Correlations = new List<CorrelationResult>()
                    };
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error in analysis worker: {ex.Message}");
                e.Result = $"Analysis error: {ex.Message}";
            }
        }
        
        private void AnalysisWorker_ProgressChanged(object? sender, ProgressChangedEventArgs e)
        {
            try
            {
                progressBar.Value = e.ProgressPercentage;
                
                if (e.UserState != null)
                {
                    txtStatus.Text = e.UserState.ToString();
                    txtProgress.Text = $"{e.ProgressPercentage}%";
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error updating progress: {ex.Message}");
            }
        }
        
        private void AnalysisWorker_RunWorkerCompleted(object? sender, RunWorkerCompletedEventArgs e)
        {
            try
            {
                if (e.Cancelled)
                {
                    txtStatus.Text = "Analysis cancelled";
                    MessageBox.Show("Analysis was cancelled by user.", "Cancelled", 
                        MessageBoxButton.OK, MessageBoxImage.Information);
                }
                else if (e.Error != null)
                {
                    txtStatus.Text = "Analysis error";
                    MessageBox.Show($"Error during analysis: {e.Error.Message}", "Error", 
                        MessageBoxButton.OK, MessageBoxImage.Error);
                }
                else
                {
                    if (e.Result is AnalysisResults results)
                    {
                        // Save results
                        _statistics = results.Statistics;
                        _detectedSignals = results.DetectedSignals;
                        _allSignals = results.AllSignals;
                        _correlations = results.Correlations;
                        
                        // Update UI
                        UpdateAnalysisUI();
                        
                        txtStatus.Text = $"Analysis complete: {_allSignals.Count} signals, {_correlations.Count} correlations";
                        
                        MessageBox.Show($"Analysis complete!\n\n" +
                                      $"Messages analyzed: {_statistics.Count}\n" +
                                      $"Signals detected: {_allSignals.Count}\n" +
                                      $"Correlations found: {_correlations.Count}", 
                                      "Analysis Complete", 
                                      MessageBoxButton.OK, MessageBoxImage.Information);
                    }
                    else if (e.Result is string errorMessage)
                    {
                        txtStatus.Text = "Analysis error";
                        MessageBox.Show(errorMessage, "Error", 
                            MessageBoxButton.OK, MessageBoxImage.Error);
                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error completing analysis: {ex.Message}", "Error", 
                    MessageBoxButton.OK, MessageBoxImage.Error);
                txtStatus.Text = "Analysis error";
            }
            finally
            {
                ResetAnalysisUI();
            }
        }
        
        private void UpdateAnalysisUI()
        {
            try
            {
                // Update signal list
                UpdateSignalList();
                
                // Update correlation list
                UpdateCorrelationList();
                
                // Update decoded signals tab
                UpdateDecodedSignalsTab();
                
                // If there are signals, select first for display
                if (_allSignals.Any())
                {
                    lvSignals.SelectedIndex = 0;
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error updating analysis UI: {ex.Message}");
            }
        }
        
        private void ResetAnalysisUI()
        {
            btnAnalyze.IsEnabled = true;
            btnAnalyze.Content = "🔍 Analyze";
            progressBar.IsIndeterminate = false;
            progressBar.Value = 0;
            txtProgress.Text = "";
            _analysisCancelled = false;
        }
        
        private async void BtnGenerateDBC_Click(object sender, RoutedEventArgs e)
        {
            if (!_messages.Any() || !_detectedSignals.Any())
            {
                MessageBox.Show("Please analyze the log first to detect signals.", "Warning", 
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            
            var saveFileDialog = new SaveFileDialog
            {
                Filter = "DBC Files (*.dbc)|*.dbc|All Files (*.*)|*.*",
                Title = "Save DBC File",
                DefaultExt = "dbc",
                FileName = $"generated_{DateTime.Now:yyyyMMdd_HHmmss}.dbc"
            };
            
            if (saveFileDialog.ShowDialog() == true)
            {
                try
                {
                    txtStatus.Text = "Generating DBC file...";
                    progressBar.IsIndeterminate = true;
                    
                    await Task.Run(() =>
                    {
                        DBCGenerator.GenerateDBCForAllMessages(_messages, _statistics, saveFileDialog.FileName);
                    });
                    
                    txtStatus.Text = $"DBC file saved: {System.IO.Path.GetFileName(saveFileDialog.FileName)}";
                    MessageBox.Show($"DBC file successfully generated!\n\n" +
                                  $"Messages: {_detectedSignals.Count}\n" +
                                  $"Signals: {_allSignals.Count}\n" +
                                  $"File: {saveFileDialog.FileName}", 
                                  "DBC Generation Complete", 
                                  MessageBoxButton.OK, MessageBoxImage.Information);
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"Error generating DBC: {ex.Message}", "Error", 
                        MessageBoxButton.OK, MessageBoxImage.Error);
                    txtStatus.Text = "DBC generation error";
                }
                finally
                {
                    progressBar.IsIndeterminate = false;
                }
            }
        }
        
        private void BtnExport_Click(object sender, RoutedEventArgs e)
        {
            if (!_messages.Any())
            {
                MessageBox.Show("No data to export. Please load and analyze a log file first.", "Warning", 
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            
            var saveDialog = new SaveFileDialog
            {
                Filter = "JSON Files (*.json)|*.json|CSV Files (*.csv)|*.csv|All Files (*.*)|*.*",
                Title = "Export Results",
                DefaultExt = "json"
            };
            
            if (saveDialog.ShowDialog() == true)
            {
                try
                {
                    ExportResults(saveDialog.FileName);
                    MessageBox.Show($"Results exported to {saveDialog.FileName}", "Export Complete", 
                        MessageBoxButton.OK, MessageBoxImage.Information);
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"Error exporting results: {ex.Message}", "Error", 
                        MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
        }
        
        private void BtnSettings_Click(object sender, RoutedEventArgs e)
        {
            var settingsDialog = new SettingsWindow();
            settingsDialog.Owner = this;
            settingsDialog.ShowDialog();
        }
        
        private void LvSignals_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (lvSignals.SelectedItem is CANSignal selectedSignal)
            {
                // Update signal details
                txtSignalName.Text = selectedSignal.Name;
                txtSignalRange.Text = $"{selectedSignal.Minimum:F2} - {selectedSignal.Maximum:F2}";
                txtSignalBits.Text = $"{selectedSignal.StartBit}:{selectedSignal.Length}";
                txtSignalUnit.Text = selectedSignal.Unit;
                txtSignalScaling.Text = $"{selectedSignal.Factor:F3} * x + {selectedSignal.Offset:F3}";
                txtSignalClassification.Text = selectedSignal.Classification.ToString();
                
                // Update signal plot
                UpdateSignalPlot(selectedSignal);
            }
        }
        
        private void LvCorrelations_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (lvCorrelations.SelectedIndex >= 0 && lvCorrelations.SelectedIndex < _correlations.Count)
            {
                var correlation = _correlations[lvCorrelations.SelectedIndex];
                txtCorrelationDetails.Text = $"{correlation.SignalA?.Name ?? "Unknown"} ↔ {correlation.SignalB?.Name ?? "Unknown"}: {correlation.Correlation:F3}";
                
                // Update correlation plot
                UpdateCorrelationPlot(correlation);
            }
        }
        
        // Methods for updating interface
        
        private void UpdateRawDataGrid()
        {
            try
            {
                // Create correct data source for DataGrid
                var dataSource = _messages.Select(m => new
                {
                    Timestamp = m.Timestamp.ToString("F6"),
                    Channel = m.Channel,
                    ID = $"0x{m.ID:X}",
                    DLC = m.DLC.ToString(),
                    DataHex = m.DataHex,
                    SignalsCount = m.SignalsCount,
                    Type = m.CANType.ToString()
                }).ToList();
                
                dgRawData.ItemsSource = dataSource;
                dgRawData.Items.Refresh();
                
                Debug.WriteLine($"Raw data grid updated with {dataSource.Count} items");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error updating raw data grid: {ex.Message}");
            }
        }
        
        private void UpdateSignalList()
        {
            try
            {
                var signalList = _allSignals.Select(s => new
                {
                    Name = s.Name,
                    Type = s.SignalType.ToString(),
                    MessageID = $"0x{s.MessageID:X}",
                    Classification = s.Classification.ToString(),
                    StartBit = s.StartBit,
                    Length = s.Length
                }).ToList();
                
                lvSignals.ItemsSource = signalList;
                
                Debug.WriteLine($"Signal list updated with {signalList.Count} items");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error updating signal list: {ex.Message}");
            }
        }
        
        private void UpdateCorrelationList()
        {
            try
            {
                var correlationList = _correlations
                    .Where(c => c.IsSignificant && Math.Abs(c.Correlation) > 0.7)
                    .Take(500)
                    .Select(c => new
                    {
                        SignalAName = c.SignalA?.Name ?? "Unknown",
                        SignalBName = c.SignalB?.Name ?? "Unknown",
                        Correlation = c.Correlation.ToString("F3"),
                        Lag = c.Lag,
                        IsSignificant = c.IsSignificant ? "Yes" : "No"
                    }).ToList();
                
                lvCorrelations.ItemsSource = correlationList;
                
                Debug.WriteLine($"Correlation list updated with {correlationList.Count} items");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error updating correlation list: {ex.Message}");
            }
        }
        
        private void UpdateDecodedSignalsTab()
        {
            try
            {
                if (_allSignals.Any())
                {
                    lvSignals.ItemsSource = _allSignals;
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error updating decoded signals tab: {ex.Message}");
            }
        }
        
        private void UpdateSignalPlot(CANSignal signal)
        {
            try
            {
                SignalPlotModel.Series.Clear();
                SignalPlotModel.Axes.Clear();
                
                if (signal.PhysicalValues.Any())
                {
                    var lineSeries = new LineSeries
                    {
                        Title = signal.Name,
                        Color = OxyColors.Blue,
                        MarkerType = MarkerType.Circle,
                        MarkerSize = 3
                    };
                    
                    for (int i = 0; i < signal.PhysicalValues.Count && i < 100; i++) // Limit to 100 points
                    {
                        lineSeries.Points.Add(new DataPoint(i, signal.PhysicalValues[i]));
                    }
                    
                    SignalPlotModel.Series.Add(lineSeries);
                    
                    SignalPlotModel.Axes.Add(new LinearAxis 
                    { 
                        Position = AxisPosition.Bottom, 
                        Title = "Sample Index",
                        MajorGridlineStyle = LineStyle.Solid,
                        MinorGridlineStyle = LineStyle.Dot
                    });
                    
                    SignalPlotModel.Axes.Add(new LinearAxis 
                    { 
                        Position = AxisPosition.Left, 
                        Title = $"{signal.Unit}",
                        MajorGridlineStyle = LineStyle.Solid,
                        MinorGridlineStyle = LineStyle.Dot
                    });
                    
                    SignalPlotModel.InvalidatePlot(true);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error updating signal plot: {ex.Message}");
            }
        }
        
        private void UpdateCorrelationPlot(CorrelationResult correlation)
        {
            try
            {
                CorrelationPlotModel.Series.Clear();
                CorrelationPlotModel.Axes.Clear();
                
                if (correlation.SignalA != null && correlation.SignalB != null)
                {
                    var seriesA = new LineSeries
                    {
                        Title = correlation.SignalA.Name,
                        Color = OxyColors.Blue,
                        MarkerType = MarkerType.Circle,
                        MarkerSize = 3
                    };
                    
                    var seriesB = new LineSeries
                    {
                        Title = correlation.SignalB.Name,
                        Color = OxyColors.Red,
                        MarkerType = MarkerType.Circle,
                        MarkerSize = 3
                    };
                    
                    var valuesA = correlation.SignalA.PhysicalValues;
                    var valuesB = correlation.SignalB.PhysicalValues;
                    
                    if (valuesA.Any() && valuesB.Any())
                    {
                        double minA = valuesA.Min();
                        double maxA = valuesA.Max();
                        double minB = valuesB.Min();
                        double maxB = valuesB.Max();
                        
                        double rangeA = maxA - minA;
                        double rangeB = maxB - minB;
                        
                        int pointCount = Math.Min(valuesA.Count, valuesB.Count);
                        pointCount = Math.Min(pointCount, 100); // Limit to 100 points
                        
                        for (int i = 0; i < pointCount; i++)
                        {
                            double normA = rangeA != 0 ? (valuesA[i] - minA) / rangeA : 0;
                            double normB = rangeB != 0 ? (valuesB[i] - minB) / rangeB : 0;
                            
                            seriesA.Points.Add(new DataPoint(i, normA));
                            seriesB.Points.Add(new DataPoint(i, normB));
                        }
                        
                        CorrelationPlotModel.Series.Add(seriesA);
                        CorrelationPlotModel.Series.Add(seriesB);
                        
                        CorrelationPlotModel.Axes.Add(new LinearAxis 
                        { 
                            Position = AxisPosition.Bottom, 
                            Title = "Sample Index",
                            MajorGridlineStyle = LineStyle.Solid
                        });
                        
                        CorrelationPlotModel.Axes.Add(new LinearAxis 
                        { 
                            Position = AxisPosition.Left, 
                            Title = "Normalized Value",
                            MajorGridlineStyle = LineStyle.Solid
                        });
                        
                        CorrelationPlotModel.InvalidatePlot(true);
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error updating correlation plot: {ex.Message}");
            }
        }
        
        private uint ExtractBits(byte[] data, int startBit, int length)
        {
            uint result = 0;
            for (int i = 0; i < length; i++)
            {
                int bitPosition = startBit + i;
                int byteIndex = bitPosition / 8;
                int bitIndex = bitPosition % 8;
                
                if (byteIndex < data.Length)
                {
                    int bitValue = (data[byteIndex] >> bitIndex) & 1;
                    result |= (uint)(bitValue << i);
                }
            }
            return result;
        }
        
        private void ExportResults(string filePath)
        {
            try
            {
                using var writer = new System.IO.StreamWriter(filePath);
                
                writer.WriteLine("CANalyzer Analysis Results");
                writer.WriteLine($"Generated: {DateTime.Now}");
                writer.WriteLine($"Messages: {_messages.Count}");
                writer.WriteLine($"Signals: {_allSignals.Count}");
                writer.WriteLine($"Correlations: {_correlations.Count}");
                writer.WriteLine();
                
                writer.WriteLine("=== MESSAGE STATISTICS ===");
                foreach (var stat in _statistics.OrderByDescending(s => s.Count).Take(20))
                {
                    writer.WriteLine($"ID 0x{stat.ID:X}: {stat.Count} messages, Freq: {stat.Frequency:F2} Hz, Cycle: {stat.EstimatedCycleTime}ms");
                }
                writer.WriteLine();
                
                writer.WriteLine("=== DETECTED SIGNALS ===");
                foreach (var signal in _allSignals)
                {
                    writer.WriteLine($"Name: {signal.Name}");
                    writer.WriteLine($"  Message ID: 0x{signal.MessageID:X}");
                    writer.WriteLine($"  Bits: {signal.StartBit}:{signal.Length}");
                    writer.WriteLine($"  Type: {signal.SignalType}");
                    writer.WriteLine($"  Classification: {signal.Classification}");
                    writer.WriteLine($"  Range: {signal.Minimum:F2} - {signal.Maximum:F2}");
                    writer.WriteLine($"  Unit: {signal.Unit}");
                    writer.WriteLine($"  Scaling: {signal.Factor:F3} * x + {signal.Offset:F3}");
                    writer.WriteLine();
                }
                
                writer.WriteLine("=== CORRELATIONS ===");
                foreach (var corr in _correlations.Where(c => c.IsSignificant).Take(20))
                {
                    writer.WriteLine($"{corr.SignalA?.Name ?? "Unknown"} ↔ {corr.SignalB?.Name ?? "Unknown"}: {corr.Correlation:F3} (lag: {corr.Lag})");
                }
                
                Debug.WriteLine($"Results exported to {filePath}");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error exporting results: {ex.Message}");
                throw;
            }
        }
        
        private void Exit_Click(object sender, RoutedEventArgs e)
        {
            Application.Current.Shutdown();
        }
        
        #endregion
        
        #region Reverse Engineering Pipeline Methods
        
        private async void BtnRunPipeline_Click(object sender, RoutedEventArgs e)
        {
            if (_messages.Count == 0)
            {
                MessageBox.Show("Please load a log file first.", "Warning", 
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            
            try
            {
                txtStatus.Text = "Starting reverse engineering pipeline...";
                progressBar.IsIndeterminate = true;
                btnRunPipeline.IsEnabled = false;
                btnPreProcess.IsEnabled = false;
                btnLexicalAnalysis.IsEnabled = false;
                btnSemanticAnalysis.IsEnabled = false;
                
                // Сохраняем текущий файл во временный файл
                string tempFile = Path.GetTempFileName();
                
                try
                {
                    // Сохраняем во временный файл
                    SaveMessagesToTempFile(tempFile);
                    
                    // Шаг 1: Pre-processing
                    txtStatus.Text = "Step 1: Pre-processing...";
                    await Task.Run(() => RunPreProcessing(tempFile));
                    
                    // Проверяем результаты препроцессинга
                    if (_preProcessor == null || _preProcessor.ArbIDDictionary.Count == 0)
                    {
                        MessageBox.Show("Pre-processing failed. No ArbIDs found.", "Error", 
                            MessageBoxButton.OK, MessageBoxImage.Error);
                        return;
                    }
                    
                    // Шаг 2: Lexical Analysis
                    txtStatus.Text = "Step 2: Lexical Analysis...";
                    await Task.Run(() => RunLexicalAnalysis());
                    
                    // Проверяем результаты лексического анализа
                    if (_pipelineSignals.Count == 0)
                    {
                        MessageBox.Show("Lexical analysis failed. No signals detected.", "Error", 
                            MessageBoxButton.OK, MessageBoxImage.Error);
                        return;
                    }
                    
                    // Шаг 3: Semantic Analysis
                    txtStatus.Text = "Step 3: Semantic Analysis...";
                    await Task.Run(() => RunSemanticAnalysis());
                    
                    // Обновляем UI
                    await Dispatcher.InvokeAsync(() => UpdatePipelineUI());
                    
                    txtStatus.Text = $"Pipeline complete: {_pipelineSignals.Count} signals, {_semanticAnalyzer?.Clusters?.Count ?? 0} clusters";
                    
                    MessageBox.Show($"Reverse engineering pipeline complete!\n\n" +
                                   $"ArbIDs: {_preProcessor?.ArbIDDictionary?.Count ?? 0}\n" +
                                   $"Signals: {_pipelineSignals.Count}\n" +
                                   $"Clusters: {_semanticAnalyzer?.Clusters?.Count ?? 0}", 
                                   "Pipeline Complete", 
                                   MessageBoxButton.OK, MessageBoxImage.Information);
                }
                finally
                {
                    // Удаляем временный файл
                    if (File.Exists(tempFile))
                        File.Delete(tempFile);
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Pipeline error: {ex.Message}\n\n{ex.StackTrace}", "Error", 
                    MessageBoxButton.OK, MessageBoxImage.Error);
                txtStatus.Text = "Pipeline error";
            }
            finally
            {
                progressBar.IsIndeterminate = false;
                btnRunPipeline.IsEnabled = true;
                btnPreProcess.IsEnabled = true;
                btnLexicalAnalysis.IsEnabled = true;
                btnSemanticAnalysis.IsEnabled = true;
            }
        }
        
        private async void BtnPreProcess_Click(object sender, RoutedEventArgs e)
        {
            if (_messages.Count == 0)
            {
                MessageBox.Show("Please load a log file first.", "Warning", 
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            
            try
            {
                txtStatus.Text = "Pre-processing...";
                progressBar.IsIndeterminate = true;
                btnPreProcess.IsEnabled = false;
                
                string tempFile = Path.GetTempFileName();
                SaveMessagesToTempFile(tempFile);
                
                try
                {
                    await Task.Run(() => RunPreProcessing(tempFile));
                    
                    await Dispatcher.InvokeAsync(() => 
                    {
                        UpdatePipelineUI();
                        txtStatus.Text = $"Pre-processing complete: {_preProcessor?.ArbIDDictionary?.Count ?? 0} ArbIDs";
                        
                        if (_preProcessor != null && _preProcessor.ArbIDDictionary.Count > 0)
                        {
                            // Enable next step button
                            btnLexicalAnalysis.IsEnabled = true;
                            
                            // Show detailed info
                            var firstArbId = _preProcessor.ArbIDDictionary.Values.First();
                            Debug.WriteLine($"First ArbID: 0x{firstArbId.ID:X}, Count: {firstArbId.MessageCount}");
                        }
                    });
                }
                finally
                {
                    if (File.Exists(tempFile))
                        File.Delete(tempFile);
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Pre-processing error: {ex.Message}\n\n{ex.StackTrace}", "Error", 
                    MessageBoxButton.OK, MessageBoxImage.Error);
                txtStatus.Text = "Pre-processing error";
            }
            finally
            {
                progressBar.IsIndeterminate = false;
                btnPreProcess.IsEnabled = true;
            }
        }
        
        private async void BtnLexicalAnalysis_Click(object sender, RoutedEventArgs e)
        {
            if (_preProcessor == null || _preProcessor.ArbIDDictionary.Count == 0)
            {
                MessageBox.Show("Please run pre-processing first.", "Warning", 
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            
            try
            {
                txtStatus.Text = "Lexical Analysis...";
                progressBar.IsIndeterminate = true;
                btnLexicalAnalysis.IsEnabled = false;
                
                await Task.Run(() => RunLexicalAnalysis());
                
                await Dispatcher.InvokeAsync(() => 
                {
                    UpdatePipelineUI();
                    txtStatus.Text = $"Lexical analysis complete: {_pipelineSignals.Count} signals";
                    
                    if (_pipelineSignals.Count > 0)
                    {
                        // Enable next step button
                        btnSemanticAnalysis.IsEnabled = true;
                        
                        // Show detailed info
                        var firstSignal = _pipelineSignals.First();
                        Debug.WriteLine($"First signal: {firstSignal.Name}, Type: {firstSignal.SignalType}");
                    }
                });
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Lexical analysis error: {ex.Message}\n\n{ex.StackTrace}", "Error", 
                    MessageBoxButton.OK, MessageBoxImage.Error);
                txtStatus.Text = "Lexical analysis error";
            }
            finally
            {
                progressBar.IsIndeterminate = false;
                btnLexicalAnalysis.IsEnabled = true;
            }
        }
        
        private async void BtnSemanticAnalysis_Click(object sender, RoutedEventArgs e)
        {
            if (_lexicalAnalyzer == null || _pipelineSignals.Count == 0)
            {
                MessageBox.Show("Please run lexical analysis first.", "Warning", 
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            
            try
            {
                txtStatus.Text = "Semantic Analysis...";
                progressBar.IsIndeterminate = true;
                btnSemanticAnalysis.IsEnabled = false;
                
                await Task.Run(() => RunSemanticAnalysis());
                
                await Dispatcher.InvokeAsync(() => 
                {
                    UpdatePipelineUI();
                    txtStatus.Text = $"Semantic analysis complete: {_semanticAnalyzer?.Clusters?.Count ?? 0} clusters";
                    
                    if (_semanticAnalyzer != null && _semanticAnalyzer.Clusters.Count > 0)
                    {
                        // Show detailed info
                        var firstCluster = _semanticAnalyzer.Clusters.First();
                        Debug.WriteLine($"First cluster: {firstCluster.Key}, Signals: {firstCluster.Value.Count}");
                    }
                });
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Semantic analysis error: {ex.Message}\n\n{ex.StackTrace}", "Error", 
                    MessageBoxButton.OK, MessageBoxImage.Error);
                txtStatus.Text = "Semantic analysis error";
            }
            finally
            {
                progressBar.IsIndeterminate = false;
                btnSemanticAnalysis.IsEnabled = true;
            }
        }
        
        private void RunPreProcessing(string filePath)
        {
            try
            {
                Debug.WriteLine($"Running pre-processing on: {filePath}");
                
                _preProcessor = new CANPreProcessor();
                
                // Определяем формат файла - временный файл всегда в CSV формате
                LogFormat format = LogFormat.CSV;
                
                // Обрабатываем файл с помощью CANPreProcessor
                _preProcessor.ProcessLogFile(filePath, format);
                
                Debug.WriteLine($"Pre-processing complete: {_preProcessor.ArbIDDictionary.Count} ArbIDs, " +
                               $"{_preProcessor.TotalMessages} messages processed");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error in RunPreProcessing: {ex.Message}\n{ex.StackTrace}");
                throw;
            }
        }
        
        private void SaveMessagesToTempFile(string tempFile)
        {
            using var writer = new StreamWriter(tempFile, false, Encoding.UTF8);
            
            // Write PEAK-Converter compatible CSV header
            writer.WriteLine("Time (ms),ID/PID (hex),Length,Data0,Data1,Data2,Data3,Data4,Data5,Data6,Data7");
            
            // Write messages
            foreach (var message in _messages)
            {
                // Convert timestamp to milliseconds (PEAK-Converter format)
                double timestampMs = message.Timestamp * 1000.0;
                
                // Format ID as hex
                string idHex = message.ID.ToString("X");
                
                // Format data bytes
                string[] dataBytes = new string[8];
                for (int i = 0; i < 8; i++)
                {
                    if (i < message.Data.Length && i < message.DLC)
                    {
                        dataBytes[i] = message.Data[i].ToString("X2");
                    }
                    else
                    {
                        dataBytes[i] = "00"; // Fill with zeros
                    }
                }
                
                // Write CSV line
                writer.WriteLine($"{timestampMs:F6},{idHex},{message.DLC}," +
                                $"{dataBytes[0]},{dataBytes[1]},{dataBytes[2]},{dataBytes[3]}," +
                                $"{dataBytes[4]},{dataBytes[5]},{dataBytes[6]},{dataBytes[7]}");
            }
            
            Debug.WriteLine($"Saved {_messages.Count} messages to temp file: {tempFile}");
        }
        
        private void RunLexicalAnalysis()
        {
            if (_preProcessor == null || _preProcessor.ArbIDDictionary.Count == 0)
                throw new InvalidOperationException("Pre-processing not completed");
            
            _lexicalAnalyzer = new CANLexicalAnalyzer();
            _lexicalAnalyzer.Analyze(_preProcessor.ArbIDDictionary);
            _pipelineSignals = _lexicalAnalyzer.SignalList;
        }
        
        private void RunSemanticAnalysis()
        {
            if (_lexicalAnalyzer == null || _pipelineSignals.Count == 0)
                throw new InvalidOperationException("Lexical analysis not completed");
            
            _semanticAnalyzer = new CANSemanticAnalyzer();
            _semanticAnalyzer.SetSignals(_pipelineSignals);
            _semanticAnalyzer.Analyze(_pipelineSignals);
        }
        
        private void UpdatePipelineUI()
        {
            try
            {
                // Update ArbIDs grid
                if (_preProcessor != null)
                {
                    var arbIDList = _preProcessor.ArbIDDictionary.Values
                        .Select(a => new
                        {
                            ID = $"0x{a.ID:X}",
                            a.Name,
                            a.MessageCount,
                            Frequency = $"{a.Frequency:F2} Hz",
                            a.DLC,
                            a.IsJ1979Standard,
                            J1979Param = a.J1979Parameter
                        })
                        .OrderByDescending(a => a.MessageCount)
                        .ToList();
                    
                    dgPipelineArbIDs.ItemsSource = arbIDList;
                    dgPipelineArbIDs.Items.Refresh();
                    
                    Debug.WriteLine($"Updated ArbIDs grid with {arbIDList.Count} items");
                }
                
                // Update signals list
                var pipelineSignalDisplay = _pipelineSignals
                    .Select(s => new
                    {
                        s.Name,
                        ArbID = s.ArbIDName,
                        Byte = s.ByteIndex,
                        Type = s.SignalType.ToString(),
                        Min = s.Minimum.ToString("F2"),
                        Max = s.Maximum.ToString("F2"),
                        s.Unit,
                        s.ClusterLabel
                    })
                    .ToList();
                
                lvPipelineSignals.ItemsSource = pipelineSignalDisplay;
                lvPipelineSignals.Items.Refresh();
                
                Debug.WriteLine($"Updated signals list with {pipelineSignalDisplay.Count} items");
                
                // Update clusters
                if (_semanticAnalyzer != null && _semanticAnalyzer.Clusters != null)
                {
                    var clusterInfo = _semanticAnalyzer.Clusters
                        .Select(c => new
                        {
                            ClusterId = c.Key,
                            SignalCount = c.Value.Count,
                            SignalNames = string.Join(", ", c.Value.Select(s => s.Name).Take(3))
                        })
                        .ToList();
                    
                    lvClusters.ItemsSource = clusterInfo;
                    lvClusters.Items.Refresh();
                    
                    Debug.WriteLine($"Updated clusters list with {clusterInfo.Count} items");
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error updating pipeline UI: {ex.Message}\n{ex.StackTrace}");
            }
        }
        
        private void LvPipelineSignals_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (lvPipelineSignals.SelectedItem != null)
            {
                dynamic selectedItem = lvPipelineSignals.SelectedItem;
                string signalName = selectedItem.Name;
                
                var selectedSignal = _pipelineSignals.FirstOrDefault(s => s.Name == signalName);
                if (selectedSignal != null)
                {
                    txtPipelineArbID.Text = selectedSignal.ArbIDName;
                    txtPipelineByte.Text = selectedSignal.ByteIndex.ToString();
                    txtPipelineRange.Text = $"{selectedSignal.Minimum:F2} - {selectedSignal.Maximum:F2}";
                    txtPipelineUnique.Text = selectedSignal.UniqueValues.ToString();
                    txtPipelineMean.Text = $"{selectedSignal.Mean:F2}";
                    txtPipelineStdDev.Text = $"{selectedSignal.StdDev:F2}";
                    
                    // Update plot
                    UpdatePipelineSignalPlot(selectedSignal);
                }
            }
        }
        
        private void LvClusters_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (lvClusters.SelectedItem != null && _semanticAnalyzer != null)
            {
                dynamic selectedItem = lvClusters.SelectedItem;
                int clusterId = selectedItem.ClusterId;
                
                var clusterSignals = _semanticAnalyzer.GetSignalsInCluster(clusterId);
                txtClusterInfo.Text = $"Cluster {clusterId}: {clusterSignals.Count} signals";
                
                // Update cluster plot
                UpdateClusterPlot(clusterSignals, clusterId);
            }
        }
        
        private void UpdatePipelineSignalPlot(Signal signal)
        {
            PipelinePlotModel.Series.Clear();
            PipelinePlotModel.Axes.Clear();
            
            if (signal.TimeSeries.Any() && signal.Timestamps.Any())
            {
                var lineSeries = new LineSeries
                {
                    Title = signal.Name,
                    Color = OxyColors.Blue,
                    MarkerType = MarkerType.Circle,
                    MarkerSize = 2
                };
                
                // Limit to 200 points for performance
                int step = Math.Max(1, signal.TimeSeries.Count / 200);
                for (int i = 0; i < signal.TimeSeries.Count; i += step)
                {
                    if (i < signal.Timestamps.Count)
                    {
                        lineSeries.Points.Add(new DataPoint(signal.Timestamps[i], signal.TimeSeries[i]));
                    }
                }
                
                PipelinePlotModel.Series.Add(lineSeries);
                
                PipelinePlotModel.Axes.Add(new LinearAxis 
                { 
                    Position = AxisPosition.Bottom, 
                    Title = "Time (s)",
                    MajorGridlineStyle = LineStyle.Solid
                });
                
                PipelinePlotModel.Axes.Add(new LinearAxis 
                { 
                    Position = AxisPosition.Left, 
                    Title = signal.Unit,
                    MajorGridlineStyle = LineStyle.Solid
                });
                
                PipelinePlotModel.InvalidatePlot(true);
            }
        }
        
        private void UpdateClusterPlot(List<Signal> signals, int clusterId)
        {
            ClusterPlotModel.Series.Clear();
            ClusterPlotModel.Axes.Clear();
            
            if (!signals.Any()) return;
            
            // Create a series for each signal in the cluster (normalized)
            var colors = new[] { OxyColors.Blue, OxyColors.Red, OxyColors.Green, OxyColors.Orange, 
                                 OxyColors.Purple, OxyColors.Brown, OxyColors.Pink };
            
            for (int i = 0; i < Math.Min(signals.Count, 7); i++)
            {
                var signal = signals[i];
                if (!signal.TimeSeries.Any() || !signal.Timestamps.Any()) continue;
                
                var lineSeries = new LineSeries
                {
                    Title = signal.Name,
                    Color = colors[i % colors.Length],
                    MarkerType = MarkerType.None,
                    LineStyle = i == 0 ? LineStyle.Solid : LineStyle.Dash
                };
                
                // Normalize the signal to 0-1 range for comparison
                double min = signal.TimeSeries.Min();
                double max = signal.TimeSeries.Max();
                double range = max - min;
                
                int step = Math.Max(1, signal.TimeSeries.Count / 100);
                for (int j = 0; j < signal.TimeSeries.Count; j += step)
                {
                    if (j < signal.Timestamps.Count)
                    {
                        double normalizedValue = range > 0 ? (signal.TimeSeries[j] - min) / range : 0.5;
                        lineSeries.Points.Add(new DataPoint(signal.Timestamps[j], normalizedValue));
                    }
                }
                
                ClusterPlotModel.Series.Add(lineSeries);
            }
            
            ClusterPlotModel.Axes.Add(new LinearAxis 
            { 
                Position = AxisPosition.Bottom, 
                Title = "Time (s)",
                MajorGridlineStyle = LineStyle.Solid
            });
            
            ClusterPlotModel.Axes.Add(new LinearAxis 
            { 
                Position = AxisPosition.Left, 
                Title = "Normalized Value",
                MajorGridlineStyle = LineStyle.Solid
            });
            
            ClusterPlotModel.Title = $"Cluster {clusterId} Signals";
            ClusterPlotModel.InvalidatePlot(true);
        }
        
        private void BtnExportPipeline_Click(object sender, RoutedEventArgs e)
        {
            if (_pipelineSignals.Count == 0)
            {
                MessageBox.Show("Run the pipeline first to generate results.", "Warning", 
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            
            var saveDialog = new SaveFileDialog
            {
                Filter = "CSV Files (*.csv)|*.csv|JSON Files (*.json)|*.json|All Files (*.*)|*.*",
                Title = "Export Pipeline Results",
                DefaultExt = "csv"
            };
            
            if (saveDialog.ShowDialog() == true)
            {
                try
                {
                    ExportPipelineResults(saveDialog.FileName);
                    MessageBox.Show($"Pipeline results exported to {saveDialog.FileName}", "Export Complete", 
                        MessageBoxButton.OK, MessageBoxImage.Information);
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"Error exporting results: {ex.Message}", "Error", 
                        MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
        }
        
        private void ExportPipelineResults(string filePath)
        {
            using var writer = new StreamWriter(filePath);
            
            // Write header
            writer.WriteLine("Reverse Engineering Pipeline Results");
            writer.WriteLine($"Generated: {DateTime.Now}");
            writer.WriteLine($"Pipeline based on CAN_Reverse_Engineering methodology");
            writer.WriteLine();
            
            if (_preProcessor != null)
            {
                writer.WriteLine("=== ARBID STATISTICS ===");
                writer.WriteLine("ID,Name,Count,Frequency,DLC,J1979");
                
                foreach (var arbId in _preProcessor.ArbIDDictionary.Values.OrderByDescending(a => a.MessageCount))
                {
                    writer.WriteLine($"{arbId.ID:X},{arbId.Name},{arbId.MessageCount},{arbId.Frequency:F2},{arbId.DLC},{arbId.J1979Parameter}");
                }
                writer.WriteLine();
            }
            
            writer.WriteLine("=== DETECTED SIGNALS ===");
            writer.WriteLine("Name,ArbID,Byte,Type,Min,Max,Mean,StdDev,UniqueValues,Cluster");
            
            foreach (var signal in _pipelineSignals)
            {
                writer.WriteLine($"{signal.Name},{signal.ArbIDName},{signal.ByteIndex},{signal.SignalType}," +
                                $"{signal.Minimum:F2},{signal.Maximum:F2},{signal.Mean:F2},{signal.StdDev:F2}," +
                                $"{signal.UniqueValues},{signal.ClusterLabel}");
            }
            writer.WriteLine();
            
            if (_semanticAnalyzer != null)
            {
                writer.WriteLine("=== CLUSTERS ===");
                foreach (var cluster in _semanticAnalyzer.Clusters)
                {
                    writer.WriteLine($"Cluster {cluster.Key}: {cluster.Value.Count} signals");
                    foreach (var signal in cluster.Value)
                    {
                        writer.WriteLine($"  {signal.Name} ({signal.SignalType})");
                    }
                    writer.WriteLine();
                }
            }
        }
        
        #endregion
        
        // Helper classes for data transfer
        private class AnalysisParameters
        {
            public List<CANMessage> Messages { get; set; } = new List<CANMessage>();
            public int MessageCount { get; set; }
        }
        
        private class AnalysisResults
        {
            public List<MessageStatistics> Statistics { get; set; } = new List<MessageStatistics>();
            public Dictionary<uint, List<CANSignal>> DetectedSignals { get; set; } = new Dictionary<uint, List<CANSignal>>();
            public List<CANSignal> AllSignals { get; set; } = new List<CANSignal>();
            public List<CorrelationResult> Correlations { get; set; } = new List<CorrelationResult>();
        }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////

SettingsWindow.xaml///////////////////////////////////////////////////////////////////////////
<Window x:Class="CANalyzer.WPF.Views.SettingsWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d"
        Title="Settings" Height="400" Width="600"
        WindowStartupLocation="CenterOwner">
    
    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>
        
        <TextBlock Grid.Row="0" Text="CANalyzer Settings" 
                  FontSize="16" FontWeight="Bold" Margin="0,0,0,10"/>
        
        <TabControl Grid.Row="1">
            <TabItem Header="General">
                <ScrollViewer>
                    <StackPanel Margin="10">
                        <GroupBox Header="Log Parsing" Margin="0,0,0,10">
                            <StackPanel>
                                <CheckBox x:Name="chkAutoDetectFormat" Content="Auto-detect log format" 
                                          IsChecked="True" Margin="5"/>
                                <CheckBox x:Name="chkShowWarnings" Content="Show parsing warnings" 
                                          IsChecked="True" Margin="5"/>
                                <StackPanel Orientation="Horizontal" Margin="5,10,5,0">
                                    <TextBlock Text="Default DLC:" VerticalAlignment="Center" Width="100"/>
                                    <TextBox x:Name="txtDefaultDLC" Text="8" Width="50"/>
                                </StackPanel>
                            </StackPanel>
                        </GroupBox>
                        
                        <GroupBox Header="Signal Detection">
                            <StackPanel>
                                <CheckBox x:Name="chkMultiByteDetection" Content="Enable multi-byte signal detection" 
                                          IsChecked="True" Margin="5"/>
                                <CheckBox x:Name="chkAutoScaling" Content="Auto-detect signal scaling" 
                                          IsChecked="True" Margin="5"/>
                                <StackPanel Orientation="Horizontal" Margin="5,10,5,0">
                                    <TextBlock Text="Minimum signal length:" VerticalAlignment="Center" Width="150"/>
                                    <TextBox x:Name="txtMinSignalLength" Text="1" Width="50"/>
                                </StackPanel>
                                <StackPanel Orientation="Horizontal" Margin="5,10,5,0">
                                    <TextBlock Text="Maximum signal length:" VerticalAlignment="Center" Width="150"/>
                                    <TextBox x:Name="txtMaxSignalLength" Text="32" Width="50"/>
                                </StackPanel>
                            </StackPanel>
                        </GroupBox>
                    </StackPanel>
                </ScrollViewer>
            </TabItem>
            
            <TabItem Header="Analysis">
                <ScrollViewer>
                    <StackPanel Margin="10">
                        <GroupBox Header="Statistical Analysis" Margin="0,0,0,10">
                            <StackPanel>
                                <CheckBox x:Name="chkCalculateFrequency" Content="Calculate message frequency" 
                                          IsChecked="True" Margin="5"/>
                                <CheckBox x:Name="chkCalculateJitter" Content="Calculate jitter" 
                                          IsChecked="True" Margin="5"/>
                                <CheckBox x:Name="chkDetectCyclic" Content="Detect cyclic messages" 
                                          IsChecked="True" Margin="5"/>
                            </StackPanel>
                        </GroupBox>
                        
                        <GroupBox Header="ML Classification" Margin="0,0,0,10">
                            <StackPanel>
                                <CheckBox x:Name="chkEnableML" Content="Enable signal classification" 
                                          IsChecked="True" Margin="5"/>
                                <CheckBox x:Name="chkUsePretrained" Content="Use pre-trained models" 
                                          IsChecked="True" Margin="5"/>
                                <StackPanel Orientation="Horizontal" Margin="5,10,5,0">
                                    <TextBlock Text="Classification threshold:" VerticalAlignment="Center" Width="150"/>
                                    <Slider x:Name="sldClassificationThreshold" Minimum="0.5" Maximum="1.0" 
                                            Value="0.7" Width="150" TickFrequency="0.1"/>
                                    <TextBlock x:Name="txtThresholdValue" Text="0.7" Width="30" 
                                               Margin="5,0,0,0" VerticalAlignment="Center"/>
                                </StackPanel>
                            </StackPanel>
                        </GroupBox>
                        
                        <GroupBox Header="Correlation Analysis">
                            <StackPanel>
                                <CheckBox x:Name="chkEnableCorrelation" Content="Enable correlation analysis" 
                                          IsChecked="True" Margin="5"/>
                                <StackPanel Orientation="Horizontal" Margin="5,10,5,0">
                                    <TextBlock Text="Correlation threshold:" VerticalAlignment="Center" Width="150"/>
                                    <Slider x:Name="sldCorrelationThreshold" Minimum="0.3" Maximum="0.9" 
                                            Value="0.7" Width="150" TickFrequency="0.1"/>
                                    <TextBlock x:Name="txtCorrelationValue" Text="0.7" Width="30" 
                                               Margin="5,0,0,0" VerticalAlignment="Center"/>
                                </StackPanel>
                                <CheckBox x:Name="chkCrossCorrelation" Content="Calculate cross-correlation lags" 
                                          IsChecked="True" Margin="5"/>
                            </StackPanel>
                        </GroupBox>
                    </StackPanel>
                </ScrollViewer>
            </TabItem>
            
            <TabItem Header="Display">
                <ScrollViewer>
                    <StackPanel Margin="10">
                        <GroupBox Header="Interface" Margin="0,0,0,10">
                            <StackPanel>
                                <StackPanel Orientation="Horizontal" Margin="5">
                                    <TextBlock Text="Theme:" VerticalAlignment="Center" Width="100"/>
                                    <ComboBox x:Name="cmbTheme" SelectedIndex="0" Width="120">
                                        <ComboBoxItem>Light</ComboBoxItem>
                                        <ComboBoxItem>Dark</ComboBoxItem>
                                        <ComboBoxItem>Blue</ComboBoxItem>
                                    </ComboBox>
                                </StackPanel>
                                
                                <StackPanel Orientation="Horizontal" Margin="5,10,5,0">
                                    <TextBlock Text="Update interval (ms):" VerticalAlignment="Center" Width="150"/>
                                    <TextBox x:Name="txtUpdateInterval" Text="1000" Width="80"/>
                                </StackPanel>
                                
                                <CheckBox x:Name="chkAutoRefresh" Content="Auto-refresh data" 
                                          IsChecked="True" Margin="5,10,5,5"/>
                                <CheckBox x:Name="chkShowTooltips" Content="Show tooltips" 
                                          IsChecked="True" Margin="5"/>
                            </StackPanel>
                        </GroupBox>
                        
                        <GroupBox Header="Plot Settings">
                            <StackPanel>
                                <CheckBox x:Name="chkShowGrid" Content="Show grid lines" 
                                          IsChecked="True" Margin="5"/>
                                <CheckBox x:Name="chkShowLegend" Content="Show legend" 
                                          IsChecked="True" Margin="5"/>
                                <StackPanel Orientation="Horizontal" Margin="5,10,5,0">
                                    <TextBlock Text="Plot points limit:" VerticalAlignment="Center" Width="100"/>
                                    <TextBox x:Name="txtPlotPointsLimit" Text="1000" Width="80"/>
                                </StackPanel>
                            </StackPanel>
                        </GroupBox>
                    </StackPanel>
                </ScrollViewer>
            </TabItem>
            
            <TabItem Header="ML Training">
                <ScrollViewer>
                    <StackPanel Margin="10">
                        <GroupBox Header="Training Sources" Margin="0,0,0,10">
                            <StackPanel>
                                <CheckBox x:Name="chkUseCommaAI" Content="Use comma.ai OpenDBC" 
                                          IsChecked="True" Margin="5"/>
                                <CheckBox x:Name="chkUseBYD" Content="Use BYD OpenDBC" 
                                          IsChecked="True" Margin="5"/>
                                <CheckBox x:Name="chkUseJejuSoul" Content="Use JejuSoul OBD PIDs" 
                                          IsChecked="True" Margin="5"/>
                                <CheckBox x:Name="chkUseGENIVI" Content="Use GENIVI CANdevStudio" 
                                          IsChecked="True" Margin="5"/>
                                <CheckBox x:Name="chkUseBukapilot" Content="Use Bukapilot OpenDBC" 
                                          IsChecked="True" Margin="5"/>
                            </StackPanel>
                        </GroupBox>
                        
                        <GroupBox Header="Training Parameters">
                            <StackPanel>
                                <StackPanel Orientation="Horizontal" Margin="5">
                                    <TextBlock Text="Training epochs:" VerticalAlignment="Center" Width="120"/>
                                    <TextBox x:Name="txtTrainingEpochs" Text="100" Width="80"/>
                                </StackPanel>
                                
                                <StackPanel Orientation="Horizontal" Margin="5,10,5,0">
                                    <TextBlock Text="Batch size:" VerticalAlignment="Center" Width="120"/>
                                    <TextBox x:Name="txtBatchSize" Text="32" Width="80"/>
                                </StackPanel>
                                
                                <StackPanel Orientation="Horizontal" Margin="5,10,5,0">
                                    <TextBlock Text="Learning rate:" VerticalAlignment="Center" Width="120"/>
                                    <TextBox x:Name="txtLearningRate" Text="0.001" Width="80"/>
                                </StackPanel>
                                
                                <Button x:Name="btnTrainModel" Content="Train Model" 
                                        Width="120" Height="30" Margin="5,20,5,5" 
                                        Click="BtnTrainModel_Click"/>
                            </StackPanel>
                        </GroupBox>
                    </StackPanel>
                </ScrollViewer>
            </TabItem>
        </TabControl>
        
        <StackPanel Grid.Row="2" Orientation="Horizontal" 
                    HorizontalAlignment="Right" Margin="0,10,0,0">
            <Button Content="OK" Width="80" Height="30" Margin="5" 
                    Click="BtnOK_Click"/>
            <Button Content="Cancel" Width="80" Height="30" Margin="5" 
                    Click="BtnCancel_Click"/>
            <Button Content="Apply" Width="80" Height="30" Margin="5" 
                    Click="BtnApply_Click"/>
        </StackPanel>
    </Grid>
</Window>
//////////////////////////////////////////////////////////////////////////////////////////////

SettingsWindow.xaml.cs////////////////////////////////////////////////////////////////////////
using System;
using System.Net.Http;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using Microsoft.Win32;
using CANalyzer.ML.NeuralNetworks;

namespace CANalyzer.WPF.Views
{
    public partial class SettingsWindow : Window
    {
        public SettingsWindow()
        {
            InitializeComponent();
            Loaded += SettingsWindow_Loaded;
            
            // Привязка событий изменения значений
            sldClassificationThreshold.ValueChanged += ThresholdSlider_ValueChanged;
            sldCorrelationThreshold.ValueChanged += CorrelationSlider_ValueChanged;
        }
        
        private void SettingsWindow_Loaded(object sender, RoutedEventArgs e)
        {
            // Инициализация значений из настроек
            txtThresholdValue.Text = sldClassificationThreshold.Value.ToString("F2");
            txtCorrelationValue.Text = sldCorrelationThreshold.Value.ToString("F2");
        }
        
        private void ThresholdSlider_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
        {
            txtThresholdValue.Text = sldClassificationThreshold.Value.ToString("F2");
        }
        
        private void CorrelationSlider_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
        {
            txtCorrelationValue.Text = sldCorrelationThreshold.Value.ToString("F2");
        }
        
        private void BtnOK_Click(object sender, RoutedEventArgs e)
        {
            SaveSettings();
            DialogResult = true;
            Close();
        }
        
        private void BtnCancel_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = false;
            Close();
        }
        
        private void BtnApply_Click(object sender, RoutedEventArgs e)
        {
            SaveSettings();
            MessageBox.Show("Settings applied successfully.", "Settings", 
                MessageBoxButton.OK, MessageBoxImage.Information);
        }
        
        private async void BtnTrainModel_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                btnTrainModel.IsEnabled = false;
                btnTrainModel.Content = "Training...";
                
                await Task.Run(async () =>
                {
                    var classifier = new SignalClassifier();
                    
                    // Загрузка данных из указанных источников
                    await classifier.LoadTrainingDataFromSources(
                        useCommaAI: chkUseCommaAI.IsChecked == true,
                        useBYD: chkUseBYD.IsChecked == true,
                        useJejuSoul: chkUseJejuSoul.IsChecked == true,
                        useGENIVI: chkUseGENIVI.IsChecked == true,
                        useBukapilot: chkUseBukapilot.IsChecked == true
                    );
                    
                    // Обучение модели с параметрами из UI
                    int epochs = int.TryParse(txtTrainingEpochs.Text, out int e) ? e : 100;
                    int batchSize = int.TryParse(txtBatchSize.Text, out int b) ? b : 32;
                    double learningRate = double.TryParse(txtLearningRate.Text, out double lr) ? lr : 0.001;
                    
                    await classifier.TrainModelAsync(epochs, batchSize, learningRate);
                    
                    // Сохранение модели
                    classifier.SaveModel("signal_classifier.model");
                });
                
                MessageBox.Show("Model trained and saved successfully!", "Training Complete", 
                    MessageBoxButton.OK, MessageBoxImage.Information);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error training model: {ex.Message}", "Training Error", 
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                btnTrainModel.IsEnabled = true;
                btnTrainModel.Content = "Train Model";
            }
        }
        
        private void SaveSettings()
        {
            try
            {
                // Здесь можно сохранить настройки в файл или базу данных
                Console.WriteLine("Settings saved:");
                Console.WriteLine($"Default DLC: {txtDefaultDLC.Text}");
                Console.WriteLine($"Min Signal Length: {txtMinSignalLength.Text}");
                Console.WriteLine($"Max Signal Length: {txtMaxSignalLength.Text}");
                Console.WriteLine($"Classification Threshold: {sldClassificationThreshold.Value:F2}");
                Console.WriteLine($"Correlation Threshold: {sldCorrelationThreshold.Value:F2}");
                Console.WriteLine($"Update Interval: {txtUpdateInterval.Text}ms");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error saving settings: {ex.Message}");
            }
        }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////

CANalyzer.ML.csproj///////////////////////////////////////////////////////////////////////////
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <Platforms>AnyCPU;x86</Platforms>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="MathNet.Numerics" Version="5.0.0" />
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\CANalyzer.Core\CANalyzer.Core.csproj" />
  </ItemGroup>
</Project>
//////////////////////////////////////////////////////////////////////////////////////////////

SignalClassifier.cs///////////////////////////////////////////////////////////////////////////
// CANalyzer.ML/NeuralNetworks/SignalClassifier.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Net.Http;
using System.Threading.Tasks;
using CANalyzer.Core.Models;

namespace CANalyzer.ML.NeuralNetworks
{
    public class SignalClassifier
    {
        private readonly HttpClient _httpClient;
        
        public SignalClassifier()
        {
            _httpClient = new HttpClient();
        }
        
        // Упрощенная версия без ML зависимостей
        public SignalClassification ClassifySignal(CANSignal signal)
        {
            if (signal.RawValues == null || signal.RawValues.Count < 10)
                return SignalClassification.Unknown;
            
            // Простая эвристическая классификация без ML
            return ClassifyByHeuristics(signal);
        }
        
        private SignalClassification ClassifyByHeuristics(CANSignal signal)
        {
            var values = signal.PhysicalValues ?? new List<double>();
            
            if (values.Count == 0)
                return SignalClassification.Unknown;
            
            // Анализ имени сигнала
            string nameLower = signal.Name.ToLower();
            
            if (nameLower.Contains("temp") || nameLower.Contains("temperature"))
                return SignalClassification.Sensor;
            
            if (nameLower.Contains("rpm") || nameLower.Contains("speed") || nameLower.Contains("velocity"))
                return SignalClassification.Sensor;
            
            if (nameLower.Contains("voltage") || nameLower.Contains("current") || nameLower.Contains("ampere"))
                return SignalClassification.Sensor;
            
            if (nameLower.Contains("pressure") || nameLower.Contains("force") || nameLower.Contains("torque"))
                return SignalClassification.Sensor;
            
            if (nameLower.Contains("position") || nameLower.Contains("angle") || nameLower.Contains("distance"))
                return SignalClassification.Sensor;
            
            if (nameLower.Contains("status") || nameLower.Contains("state") || nameLower.Contains("mode"))
                return SignalClassification.Status;
            
            if (nameLower.Contains("error") || nameLower.Contains("fault") || nameLower.Contains("warning"))
                return SignalClassification.Diagnostic;
            
            if (nameLower.Contains("command") || nameLower.Contains("control") || nameLower.Contains("setpoint"))
                return SignalClassification.Control;
            
            if (nameLower.Contains("actuator") || nameLower.Contains("motor") || nameLower.Contains("valve"))
                return SignalClassification.Actuator;
            
            // Анализ значений
            if (signal.SignalType == SignalType.Boolean)
                return SignalClassification.Status;
            
            if (signal.SignalType == SignalType.Enum)
                return SignalClassification.Status;
            
            // Анализ статистики значений
            if (values.Count >= 10)
            {
                double mean = values.Average();
                double variance = values.Select(v => Math.Pow(v - mean, 2)).Average();
                double stdDev = Math.Sqrt(variance);
                
                // Если значения почти не меняются - статус
                if (stdDev < 0.01 * mean)
                    return SignalClassification.Status;
                
                // Если значения постоянно меняются - сенсор
                if (stdDev > 0.1 * mean)
                    return SignalClassification.Sensor;
            }
            
            return SignalClassification.Unknown;
        }
        
        // Простые методы для совместимости
        public async Task LoadTrainingDataFromSources(bool useCommaAI, bool useBYD, 
            bool useJejuSoul, bool useGENIVI, bool useBukapilot)
        {
            // Заглушка для совместимости
            await Task.CompletedTask;
        }
        
        public async Task TrainModelAsync(int epochs = 100, int batchSize = 32, double learningRate = 0.001)
        {
            // Заглушка для совместимости
            await Task.CompletedTask;
        }
        
        public void SaveModel(string path)
        {
            try
            {
                // Просто создаем пустой файл для совместимости
                File.WriteAllText(path, "Simple heuristic model - no ML dependencies");
            }
            catch { }
        }
        
        public void LoadModel(string path)
        {
            // Заглушка для совместимости
        }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////

CANalyzer.Correlation.csproj//////////////////////////////////////////////////////////////////
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
  
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
    <PlatformTarget>AnyCPU</PlatformTarget>
  </PropertyGroup>
  
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|AnyCPU'">
    <PlatformTarget>AnyCPU</PlatformTarget>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="MathNet.Numerics" Version="5.0.0" />
  </ItemGroup>
  
  <ItemGroup>
    <ProjectReference Include="..\CANalyzer.Core\CANalyzer.Core.csproj" />
  </ItemGroup>
</Project>
//////////////////////////////////////////////////////////////////////////////////////////////

CorrelationAnalyzer.cs////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.Linq;
using MathNet.Numerics.Statistics;
using CANalyzer.Core.Models;

namespace CANalyzer.Correlation.Analyzers
{
    public class CorrelationResult
    {
        public CANSignal? SignalA { get; set; }
        public CANSignal? SignalB { get; set; }
        public double Correlation { get; set; }
        public int Lag { get; set; }
        public bool IsSignificant { get; set; }
        public double PValue { get; set; }
        public string Relationship { get; set; } = string.Empty;
    }

    public class CorrelationAnalyzer
    {
        private const double SIGNIFICANCE_THRESHOLD = 0.7;
        private const double PVALUE_THRESHOLD = 0.05;

        public List<CorrelationResult> AnalyzeCorrelations(List<CANSignal> signals)
        {
            var results = new List<CorrelationResult>();

            if (signals == null || signals.Count < 2)
                return results;

            // Фильтруем сигналы для корреляционного анализа
            var validSignals = signals
                .Where(s => s.PhysicalValues != null && s.PhysicalValues.Count > 10)
                .ToList();

            if (validSignals.Count < 2)
                return results;

            // Группируем сигналы по сообщениям для анализа внутри одного сообщения
            var signalsByMessage = validSignals
                .GroupBy(s => s.MessageID)
                .Where(g => g.Count() > 1)
                .ToList();

            // Анализ корреляций внутри одного сообщения
            foreach (var messageGroup in signalsByMessage)
            {
                var messageSignals = messageGroup.ToList();
                
                for (int i = 0; i < messageSignals.Count; i++)
                {
                    for (int j = i + 1; j < messageSignals.Count; j++)
                    {
                        var signalA = messageSignals[i];
                        var signalB = messageSignals[j];
                        
                        // Пропускаем если сигналы перекрываются по байтам
                        if (SignalsOverlap(signalA, signalB))
                            continue;
                            
                        var correlation = CalculateByteCorrelation(signalA, signalB);
                        if (correlation != null)
                        {
                            results.Add(correlation);
                        }
                    }
                }
            }

            // Анализ корреляций между разными сообщениями (только для сильных корреляций)
            if (validSignals.Count > 20)
            {
                // Берем только первые 20 сигналов для производительности
                var limitedSignals = validSignals.Take(20).ToList();
                
                for (int i = 0; i < limitedSignals.Count; i++)
                {
                    for (int j = i + 1; j < limitedSignals.Count; j++)
                    {
                        var signalA = limitedSignals[i];
                        var signalB = limitedSignals[j];
                        
                        // Пропускаем если сигналы из одного сообщения (уже проанализированы)
                        if (signalA.MessageID == signalB.MessageID)
                            continue;
                            
                        var correlation = CalculateByteCorrelation(signalA, signalB);
                        if (correlation != null && correlation.IsSignificant)
                        {
                            results.Add(correlation);
                        }
                    }
                }
            }

            // Сортировка по силе корреляции
            return results.OrderByDescending(r => Math.Abs(r.Correlation)).ToList();
        }

        private bool SignalsOverlap(CANSignal signalA, CANSignal signalB)
        {
            // Проверка перекрытия байтов
            int aStartByte = signalA.StartBit / 8;
            int aEndByte = (signalA.StartBit + signalA.Length - 1) / 8;
            int bStartByte = signalB.StartBit / 8;
            int bEndByte = (signalB.StartBit + signalB.Length - 1) / 8;
            
            return !(aEndByte < bStartByte || bEndByte < aStartByte);
        }

        private CorrelationResult? CalculateByteCorrelation(CANSignal signalA, CANSignal signalB)
        {
            if (signalA.PhysicalValues == null || signalB.PhysicalValues == null)
                return null;

            var valuesA = signalA.PhysicalValues;
            var valuesB = signalB.PhysicalValues;

            // Выравнивание временных рядов по минимальной длине
            int minLength = Math.Min(valuesA.Count, valuesB.Count);
            if (minLength < 10) return null;

            var alignedA = valuesA.Take(minLength).ToList();
            var alignedB = valuesB.Take(minLength).ToList();

            try
            {
                // Расчет корреляции для байтовых данных
                double correlation = CalculatePearsonCorrelation(alignedA, alignedB);

                // Расчет запаздывания
                int lag = CalculateByteLag(alignedA, alignedB);

                // Проверка статистической значимости
                double pValue = CalculatePValue(correlation, minLength);
                bool isSignificant = Math.Abs(correlation) > SIGNIFICANCE_THRESHOLD && pValue < PVALUE_THRESHOLD;

                // Определение типа зависимости
                string relationship = DetermineByteRelationship(correlation, lag);

                return new CorrelationResult
                {
                    SignalA = signalA,
                    SignalB = signalB,
                    Correlation = correlation,
                    Lag = lag,
                    PValue = pValue,
                    IsSignificant = isSignificant,
                    Relationship = relationship
                };
            }
            catch (Exception)
            {
                return null;
            }
        }

        // Собственная реализация корреляции Пирсона
        private double CalculatePearsonCorrelation(List<double> x, List<double> y)
        {
            if (x.Count != y.Count)
                throw new ArgumentException("Arrays must have the same length");

            if (x.Count < 2)
                return 0;

            double meanX = x.Average();
            double meanY = y.Average();

            double numerator = 0;
            double denominatorX = 0;
            double denominatorY = 0;

            for (int i = 0; i < x.Count; i++)
            {
                double diffX = x[i] - meanX;
                double diffY = y[i] - meanY;

                numerator += diffX * diffY;
                denominatorX += diffX * diffX;
                denominatorY += diffY * diffY;
            }

            if (denominatorX == 0 || denominatorY == 0)
                return 0;

            return numerator / Math.Sqrt(denominatorX * denominatorY);
        }

        private int CalculateByteLag(List<double> seriesA, List<double> seriesB)
        {
            // Для байтовых данных используем меньший диапазон лагов
            int maxLag = Math.Min(10, seriesA.Count / 10);
            double maxCorrelation = 0;
            int bestLag = 0;

            for (int lag = -maxLag; lag <= maxLag; lag++)
            {
                double correlation = CalculateCrossCorrelation(seriesA, seriesB, lag);
                if (Math.Abs(correlation) > Math.Abs(maxCorrelation))
                {
                    maxCorrelation = correlation;
                    bestLag = lag;
                }
            }

            return bestLag;
        }

        private double CalculateCrossCorrelation(List<double> seriesA, List<double> seriesB, int lag)
        {
            int n = seriesA.Count;
            List<double> shiftedA, shiftedB;

            if (lag >= 0)
            {
                shiftedA = seriesA.Skip(lag).ToList();
                shiftedB = seriesB.Take(n - lag).ToList();
            }
            else
            {
                shiftedA = seriesA.Take(n + lag).ToList();
                shiftedB = seriesB.Skip(-lag).ToList();
            }

            int overlap = Math.Min(shiftedA.Count, shiftedB.Count);
            if (overlap < 10) return 0;

            shiftedA = shiftedA.Take(overlap).ToList();
            shiftedB = shiftedB.Take(overlap).ToList();

            try
            {
                return CalculatePearsonCorrelation(shiftedA, shiftedB);
            }
            catch (Exception)
            {
                return 0;
            }
        }

        private double CalculatePValue(double correlation, int n)
        {
            if (n <= 2) return 1.0;

            // Приблизительный расчет p-value для корреляции Пирсона
            double t = correlation * Math.Sqrt((n - 2) / (1 - correlation * correlation));
            double df = n - 2;

            // Используем аппроксимацию t-распределения
            double p = 2 * (1 - TDistributionCDF(Math.Abs(t), df));
            return Math.Min(Math.Max(p, 0), 1);
        }

        private double TDistributionCDF(double t, double df)
        {
            // Аппроксимация CDF t-распределения
            double x = df / (df + t * t);
            double ibeta = IncompleteBeta(0.5 * df, 0.5, x);
            return 1 - 0.5 * ibeta;
        }

        private double IncompleteBeta(double a, double b, double x)
        {
            // Упрощенная реализация неполной бета-функции
            if (x < 0 || x > 1) return 0;
            if (x == 0) return 0;
            if (x == 1) return 1;

            // Аппроксимация
            return Math.Pow(x, a) * Math.Pow(1 - x, b) / (a * Beta(a, b));
        }

        private double Beta(double a, double b)
        {
            return Math.Exp(GammaLn(a) + GammaLn(b) - GammaLn(a + b));
        }

        private double GammaLn(double x)
        {
            // Аппроксимация логарифма гамма-функции
            double[] coef = {76.18009172947146, -86.50532032941677,
                           24.01409824083091, -1.231739572450155,
                           0.1208650973866179e-2, -0.5395239384953e-5};

            double y = x;
            double tmp = x + 5.5;
            tmp -= (x + 0.5) * Math.Log(tmp);
            double ser = 1.000000000190015;

            for (int j = 0; j < 6; j++)
            {
                y += 1;
                ser += coef[j] / y;
            }

            return -tmp + Math.Log(2.5066282746310005 * ser / x);
        }

        private string DetermineByteRelationship(double correlation, int lag)
        {
            string relationship = "";

            if (correlation > 0.8)
                relationship = "Strong positive";
            else if (correlation > 0.5)
                relationship = "Moderate positive";
            else if (correlation > 0.3)
                relationship = "Weak positive";
            else if (correlation < -0.8)
                relationship = "Strong negative";
            else if (correlation < -0.5)
                relationship = "Moderate negative";
            else if (correlation < -0.3)
                relationship = "Weak negative";
            else
                relationship = "No correlation";

            // Для байтовых данных добавляем информацию о запаздывании
            if (Math.Abs(lag) > 0)
            {
                relationship += $", lag: {lag} samples";
                
                // Определение возможной причинно-следственной связи
                if (lag > 0 && correlation > 0.7)
                    relationship += $" (A → B)";
                else if (lag < 0 && correlation > 0.7)
                    relationship += $" (B → A)";
            }

            return relationship;
        }

        public List<CorrelationResult> FindCausalRelationships(List<CANSignal> signals)
        {
            // Поиск причинно-следственных связей для байтовых данных
            var correlations = AnalyzeCorrelations(signals);
            var causalResults = new List<CorrelationResult>();

            foreach (var corr in correlations.Where(c => c.IsSignificant))
            {
                // Для байтовых данных используем более строгий порог
                if (Math.Abs(corr.Lag) > 1 && Math.Abs(corr.Correlation) > 0.8)
                {
                    if (corr.Lag > 0)
                    {
                        corr.Relationship = $"Byte causation: {corr.SignalA?.Name ?? "Unknown"} → {corr.SignalB?.Name ?? "Unknown"} (lag: {corr.Lag})";
                        causalResults.Add(corr);
                    }
                    else if (corr.Lag < 0)
                    {
                        corr.Relationship = $"Byte causation: {corr.SignalB?.Name ?? "Unknown"} → {corr.SignalA?.Name ?? "Unknown"} (lag: {-corr.Lag})";
                        causalResults.Add(corr);
                    }
                }
            }

            return causalResults;
        }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////

CANalyzer.Tests.csproj////////////////////////////////////////////////////////////////////////
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsPackable>false</IsPackable>
    <Platforms>AnyCPU;x86</Platforms>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.8.0" />
    <PackageReference Include="xunit" Version="2.6.6" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.5.7">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="coverlet.collector" Version="6.0.0">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\CANalyzer.Core\CANalyzer.Core.csproj" />
    <ProjectReference Include="..\CANalyzer.ML\CANalyzer.ML.csproj" />
    <ProjectReference Include="..\CANalyzer.Correlation\CANalyzer.Correlation.csproj" />
  </ItemGroup>
</Project>
//////////////////////////////////////////////////////////////////////////////////////////////

SignalDetectorTests.cs////////////////////////////////////////////////////////////////////////
using Xunit;
using CANalyzer.Core.Models;
using CANalyzer.Core.Analyzers;
using System.Collections.Generic;

namespace CANalyzer.Tests
{
    public class SignalDetectorTests
    {
        [Fact]
        public void DetectSignals_ShouldFindBooleanSignal()
        {
            // Arrange
            var messages = new List<CANMessage>
            {
                new CANMessage { ID = 0x100, Data = new byte[] { 0x00, 0x00, 0x00, 0x00 } },
                new CANMessage { ID = 0x100, Data = new byte[] { 0x01, 0x00, 0x00, 0x00 } },
                new CANMessage { ID = 0x100, Data = new byte[] { 0x00, 0x00, 0x00, 0x00 } },
                new CANMessage { ID = 0x100, Data = new byte[] { 0x01, 0x00, 0x00, 0x00 } }
            };
            
            // Act
            var signals = SignalDetector.DetectSignals(messages, 0x100);
            
            // Assert
            Assert.NotEmpty(signals);
            Assert.Contains(signals, s => s.Length == 1 && s.SignalType == SignalType.Boolean);
        }
        
        [Fact]
        public void DetectSignals_ShouldFindMultiBitSignal()
        {
            // Arrange
            var messages = new List<CANMessage>();
            for (int i = 0; i < 10; i++)
            {
                messages.Add(new CANMessage 
                { 
                    ID = 0x200, 
                    Data = new byte[] { (byte)i, 0x00, 0x00, 0x00 } 
                });
            }
            
            // Act
            var signals = SignalDetector.DetectSignals(messages, 0x200);
            
            // Assert
            Assert.NotEmpty(signals);
            Assert.Contains(signals, s => s.Length > 1);
        }
        
        [Fact]
        public void StatisticalAnalyzer_ShouldCalculateCorrectStatistics()
        {
            // Arrange
            var messages = new List<CANMessage>
            {
                new CANMessage { ID = 0x300, Timestamp = 0.0 },
                new CANMessage { ID = 0x300, Timestamp = 0.1 },
                new CANMessage { ID = 0x300, Timestamp = 0.2 },
                new CANMessage { ID = 0x300, Timestamp = 0.3 }
            };
            
            // Act
            var stats = StatisticalAnalyzer.CalculateStatistics(messages);
            
            // Assert
            Assert.Single(stats);
            Assert.Equal(4, stats[0].Count);
            Assert.Equal(10.0, stats[0].Frequency, 1);
        }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////

CANalyzer.Scripts.csproj//////////////////////////////////////////////////////////////////////
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <Platforms>AnyCPU;x86</Platforms>
  </PropertyGroup>
  <ItemGroup>
    <ProjectReference Include="..\CANalyzer.Core\CANalyzer.Core.csproj" />
    <ProjectReference Include="..\CANalyzer.ML\CANalyzer.ML.csproj" />
  </ItemGroup>
</Project>
//////////////////////////////////////////////////////////////////////////////////////////////

Program.cs////////////////////////////////////////////////////////////////////////////////////
using System;
using System.IO;
using System.Linq;
using System.Collections.Generic;
using System.Threading.Tasks;
using CANalyzer.Core.Models;
using CANalyzer.Core.Parsers;
using CANalyzer.Core.Analyzers;
using CANalyzer.Core.DBC;
using CANalyzer.ML.NeuralNetworks;

namespace CANalyzer.Scripts
{
    class Program
    {
        static async Task Main(string[] args)
        {
            Console.WriteLine("=== CANalyzer Scripting Interface ===");
            Console.WriteLine();
            
            if (args.Length == 0)
            {
                PrintUsage();
                return;
            }
            
            string command = args[0].ToLower();
            
            switch (command)
            {
                case "analyze":
                    await AnalyzeCommandAsync(args);
                    break;
                    
                case "generate-dbc":
                    await GenerateDBCCommandAsync(args);
                    break;
                    
                case "train-model":
                    await TrainModelCommandAsync(args);
                    break;
                    
                case "batch-process":
                    await BatchProcessCommandAsync(args);
                    break;
                    
                default:
                    Console.WriteLine($"Unknown command: {command}");
                    PrintUsage();
                    break;
            }
        }
        
        static void PrintUsage()
        {
            Console.WriteLine("Usage:");
            Console.WriteLine("  CANalyzer.Scripts analyze <logfile> [format]");
            Console.WriteLine("  CANalyzer.Scripts generate-dbc <logfile> <output.dbc>");
            Console.WriteLine("  CANalyzer.Scripts train-model [output-model-path]");
            Console.WriteLine("  CANalyzer.Scripts batch-process <folder>");
            Console.WriteLine();
            Console.WriteLine("Formats: CSV, ASC, BLF");
        }
        
        static async Task AnalyzeCommandAsync(string[] args)
        {
            if (args.Length < 2)
            {
                Console.WriteLine("Error: Missing log file path");
                return;
            }
            
            string logPath = args[1];
            LogFormat format = args.Length > 2 ? 
                Enum.Parse<LogFormat>(args[2].ToUpper()) : 
                LogFormat.CSV;
            
            if (!File.Exists(logPath))
            {
                Console.WriteLine($"Error: File not found: {logPath}");
                return;
            }
            
            Console.WriteLine($"Analyzing {logPath} ({format})...");
            
            try
            {
                // 1. Загрузка лога
                var messages = await Task.Run(() => LogParser.Parse(logPath, format));
                Console.WriteLine($"  Loaded {messages.Count} messages");
                
                // 2. Статистический анализ
                var stats = await Task.Run(() => StatisticalAnalyzer.CalculateStatistics(messages));
                Console.WriteLine($"  Found {stats.Count} unique message IDs");
                
                // 3. Детекция сигналов
                int totalSignals = 0;
                var allSignals = new List<CANSignal>();
                
                var statsWithEnoughMessages = stats.Where(s => s.Count > 10).ToList();
                foreach (var stat in statsWithEnoughMessages)
                {
                    var signals = await Task.Run(() => SignalDetector.DetectSignals(messages, stat.ID));
                    if (signals.Any())
                    {
                        totalSignals += signals.Count;
                        allSignals.AddRange(signals);
                        Console.WriteLine($"    ID 0x{stat.ID:X}: {signals.Count} signals");
                    }
                }
                
                Console.WriteLine($"  Total signals detected: {totalSignals}");
                
                // 4. ML классификация
                if (allSignals.Any())
                {
                    var classifier = new SignalClassifier();
                    
                    foreach (var signal in allSignals)
                    {
                        signal.Classification = await Task.Run(() => classifier.ClassifySignal(signal));
                    }
                    
                    var byClassification = allSignals.GroupBy(s => s.Classification);
                    Console.WriteLine("  Signal classification:");
                    foreach (var group in byClassification)
                    {
                        Console.WriteLine($"    {group.Key}: {group.Count()} signals");
                    }
                }
                
                // 5. Экспорт статистики
                string statsFile = Path.ChangeExtension(logPath, ".stats.json");
                await Task.Run(() => ExportStatistics(stats, statsFile));
                Console.WriteLine($"  Statistics exported to: {statsFile}");
                
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error: {ex.Message}");
                Console.WriteLine($"Stack trace: {ex.StackTrace}");
            }
        }
        
        static async Task GenerateDBCCommandAsync(string[] args)
        {
            if (args.Length < 3)
            {
                Console.WriteLine("Error: Missing parameters");
                Console.WriteLine("Usage: generate-dbc <logfile> <output.dbc>");
                return;
            }
            
            string logPath = args[1];
            string outputPath = args[2];
            
            if (!File.Exists(logPath))
            {
                Console.WriteLine($"Error: File not found: {logPath}");
                return;
            }
            
            Console.WriteLine($"Generating DBC from {logPath}...");
            
            try
            {
                // Определение формата по расширению
                string ext = Path.GetExtension(logPath).ToLower();
                LogFormat format = ext switch
                {
                    ".csv" => LogFormat.CSV,
                    ".asc" => LogFormat.ASC,
                    ".blf" => LogFormat.BLF,
                    _ => LogFormat.CSV
                };
                
                // Загрузка и анализ
                var messages = await Task.Run(() => LogParser.Parse(logPath, format));
                var stats = await Task.Run(() => StatisticalAnalyzer.CalculateStatistics(messages));
                
                // Генерация DBC
                await Task.Run(() => DBCGenerator.GenerateDBCForAllMessages(messages, stats, outputPath));
                
                Console.WriteLine($"DBC file generated: {outputPath}");
                
                var statsWithEnoughMessages = stats.Where(s => s.Count > 10).ToList();
                Console.WriteLine($"  Messages: {statsWithEnoughMessages.Count}");
                
                // Подсчет сигналов
                int signalCount = 0;
                foreach (var stat in statsWithEnoughMessages)
                {
                    var signals = await Task.Run(() => SignalDetector.DetectSignals(messages, stat.ID));
                    signalCount += signals.Count;
                }
                
                Console.WriteLine($"  Signals: {signalCount}");
                
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error: {ex.Message}");
                Console.WriteLine($"Stack trace: {ex.StackTrace}");
            }
        }
        
        static async Task TrainModelCommandAsync(string[] args)
        {
            Console.WriteLine("Training ML model...");
            
            try
            {
                var classifier = new SignalClassifier();
                
                // Загрузка тренировочных данных из OpenDBC репозиториев
                Console.WriteLine("Loading training data from OpenDBC repositories...");
                await classifier.LoadTrainingDataFromSources(
                    useCommaAI: true,
                    useBYD: true,
                    useJejuSoul: true,
                    useGENIVI: true,
                    useBukapilot: true
                );
                
                // Обучение модели
                Console.WriteLine("Training model...");
                
                int epochs = 100;
                int batchSize = 32;
                double learningRate = 0.001;
                
                await classifier.TrainModelAsync(epochs, batchSize, learningRate);
                
                // Сохранение модели
                string modelPath = args.Length > 1 ? args[1] : "signal_classifier.model";
                classifier.SaveModel(modelPath);
                
                Console.WriteLine($"Model trained and saved to: {modelPath}");
                
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error training model: {ex.Message}");
                Console.WriteLine($"Stack trace: {ex.StackTrace}");
            }
        }
        
        static async Task BatchProcessCommandAsync(string[] args)
        {
            if (args.Length < 2)
            {
                Console.WriteLine("Error: Missing folder path");
                return;
            }
            
            string folderPath = args[1];
            
            if (!Directory.Exists(folderPath))
            {
                Console.WriteLine($"Error: Folder not found: {folderPath}");
                return;
            }
            
            var logFiles = Directory.GetFiles(folderPath, "*.csv")
                .Concat(Directory.GetFiles(folderPath, "*.asc"))
                .Concat(Directory.GetFiles(folderPath, "*.blf"))
                .ToList();
            
            Console.WriteLine($"Found {logFiles.Count} log files in {folderPath}");
            Console.WriteLine();
            
            foreach (var logFile in logFiles)
            {
                Console.WriteLine($"Processing: {Path.GetFileName(logFile)}");
                
                try
                {
                    // Автоматическое определение формата
                    string ext = Path.GetExtension(logFile).ToLower();
                    LogFormat format = ext switch
                    {
                        ".csv" => LogFormat.CSV,
                        ".asc" => LogFormat.ASC,
                        ".blf" => LogFormat.BLF,
                        _ => LogFormat.CSV
                    };
                    
                    // Анализ
                    var messages = await Task.Run(() => LogParser.Parse(logFile, format));
                    var stats = await Task.Run(() => StatisticalAnalyzer.CalculateStatistics(messages));
                    
                    Console.WriteLine($"  Messages: {messages.Count}, IDs: {stats.Count}");
                    
                    // Генерация DBC
                    string dbcFile = Path.ChangeExtension(logFile, ".dbc");
                    await Task.Run(() => DBCGenerator.GenerateDBCForAllMessages(messages, stats, dbcFile));
                    
                    Console.WriteLine($"  DBC generated: {Path.GetFileName(dbcFile)}");
                    
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"  Error: {ex.Message}");
                    Console.WriteLine($"  Stack trace: {ex.StackTrace}");
                }
                
                Console.WriteLine();
            }
        }
        
        static void ExportStatistics(List<MessageStatistics> stats, string filePath)
        {
            try
            {
                using var writer = new StreamWriter(filePath);
                writer.WriteLine("[");
                
                for (int i = 0; i < stats.Count; i++)
                {
                    var stat = stats[i];
                    writer.WriteLine("  {");
                    writer.WriteLine($"    \"ID\": \"0x{stat.ID:X}\",");
                    writer.WriteLine($"    \"Count\": {stat.Count},");
                    writer.WriteLine($"    \"Frequency\": {stat.Frequency:F2},");
                    writer.WriteLine($"    \"MinInterval\": {stat.MinInterval:F6},");
                    writer.WriteLine($"    \"MaxInterval\": {stat.MaxInterval:F6},");
                    writer.WriteLine($"    \"AvgInterval\": {stat.AvgInterval:F6},");
                    writer.WriteLine($"    \"Jitter\": {stat.Jitter:F6},");
                    writer.WriteLine($"    \"IsCyclic\": {stat.IsCyclic.ToString().ToLower()},");
                    writer.WriteLine($"    \"CycleTime\": {stat.EstimatedCycleTime}");
                    writer.Write(i < stats.Count - 1 ? "  }," : "  }");
                    writer.WriteLine();
                }
                
                writer.WriteLine("]");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error exporting statistics: {ex.Message}");
            }
        }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////

CANalyzer.ReverseEngineering.csproj///////////////////////////////////////////////////////////
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <Platforms>AnyCPU;x86</Platforms>
    <AssemblyName>CANalyzer.ReverseEngineering</AssemblyName>
    <RootNamespace>CANalyzer.ReverseEngineering</RootNamespace>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="MathNet.Numerics" Version="5.0.0" />
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
    <PackageReference Include="System.Data.DataSetExtensions" Version="4.5.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\CANalyzer.Core\CANalyzer.Core.csproj" />
  </ItemGroup>
</Project>
//////////////////////////////////////////////////////////////////////////////////////////////

ArbID.cs//////////////////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.Data;
using CANalyzer.Core.Models;

namespace CANalyzer.ReverseEngineering.Models
{
    /// <summary>
    /// Represents an Arbitration ID (ArbID) with its time series data
    /// Based on ArbID.py from CAN_Reverse_Engineering pipeline
    /// </summary>
    public class ArbID
    {
        public uint ID { get; set; }
        public string Name { get; set; } = string.Empty;
        public int DLC { get; set; }
        public int MessageCount { get; set; }
        public double FirstTimestamp { get; set; }
        public double LastTimestamp { get; set; }
        public double Frequency { get; set; }
        public bool IsCyclic { get; set; }
        public int EstimatedCycleTime { get; set; }
        public DataTable TimeSeriesData { get; set; }
        public Dictionary<int, DataColumn> ByteColumns { get; set; } = new Dictionary<int, DataColumn>();
        public Dictionary<string, Signal> Signals { get; set; } = new Dictionary<string, Signal>();
        public List<byte[]> RawDataSamples { get; set; } = new List<byte[]>();
        
        // J1979 Standard IDs (SAE Standard)
        public bool IsJ1979Standard { get; set; }
        public string J1979Parameter { get; set; } = string.Empty;
        public string J1979Description { get; set; } = string.Empty;
        
        public ArbID(uint id)
        {
            ID = id;
            Name = $"ID_{id:X}";
            TimeSeriesData = new DataTable();
            TimeSeriesData.Columns.Add("Timestamp", typeof(double));
        }
        
        public void AddDataSample(double timestamp, byte[] data)
        {
            if (data == null) return;
            
            // Update DLC if larger data encountered
            DLC = Math.Max(DLC, data.Length);
            
            // Add raw data sample
            RawDataSamples.Add(data);
            
            // Create row for time series data
            DataRow row = TimeSeriesData.NewRow();
            row["Timestamp"] = timestamp;
            
            // Ensure byte columns exist
            for (int i = 0; i < data.Length; i++)
            {
                string columnName = $"Byte_{i}";
                if (!TimeSeriesData.Columns.Contains(columnName))
                {
                    DataColumn column = new DataColumn(columnName, typeof(byte));
                    TimeSeriesData.Columns.Add(column);
                    ByteColumns[i] = column;
                }
                row[columnName] = data[i];
            }
            
            TimeSeriesData.Rows.Add(row);
            MessageCount++;
            
            // Update timestamps
            if (MessageCount == 1)
            {
                FirstTimestamp = timestamp;
            }
            LastTimestamp = timestamp;
            
            // Calculate frequency
            double timeSpan = LastTimestamp - FirstTimestamp;
            if (timeSpan > 0)
            {
                Frequency = MessageCount / timeSpan;
            }
        }
        
        public byte[] GetByteTimeSeries(int byteIndex)
        {
            if (byteIndex >= DLC || !TimeSeriesData.Columns.Contains($"Byte_{byteIndex}"))
                return Array.Empty<byte>();
                
            var result = new byte[TimeSeriesData.Rows.Count];
            for (int i = 0; i < TimeSeriesData.Rows.Count; i++)
            {
                result[i] = (byte)TimeSeriesData.Rows[i][$"Byte_{byteIndex}"];
            }
            return result;
        }
        
        public double[] GetTimestampSeries()
        {
            var result = new double[TimeSeriesData.Rows.Count];
            for (int i = 0; i < TimeSeriesData.Rows.Count; i++)
            {
                result[i] = (double)TimeSeriesData.Rows[i]["Timestamp"];
            }
            return result;
        }
        
        public override string ToString()
        {
            return $"{Name} ({ID:X}): {MessageCount} messages, {Frequency:F2} Hz, DLC: {DLC}";
        }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////

Signal.cs/////////////////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.Linq;

namespace CANalyzer.ReverseEngineering.Models
{
    /// <summary>
    /// Represents a detected signal in the CAN data
    /// Based on Signal.py from CAN_Reverse_Engineering pipeline
    /// </summary>
    public class Signal
    {
        public string Name { get; set; } = string.Empty;
        public string ArbIDName { get; set; } = string.Empty;
        public uint ArbID { get; set; }
        public int ByteIndex { get; set; }
        public int StartBit { get; set; }
        public int Length { get; set; } = 8; // Default to byte-aligned
        public Core.Models.SignalType SignalType { get; set; }
        public Core.Models.SignalValueType ValueType { get; set; }
        public double Factor { get; set; } = 1.0;
        public double Offset { get; set; } = 0.0;
        public double Minimum { get; set; }
        public double Maximum { get; set; }
        public string Unit { get; set; } = string.Empty;
        public List<double> TimeSeries { get; set; } = new List<double>();
        public List<double> Timestamps { get; set; } = new List<double>();
        public double[] RawBytes { get; set; } = Array.Empty<double>();
        public string ClusterLabel { get; set; } = string.Empty;
        public int ClusterId { get; set; } = -1;
        
        // Statistical properties
        public double Mean { get; set; }
        public double StdDev { get; set; }
        public double Variance { get; set; }
        public double Range { get; set; }
        public int UniqueValues { get; set; }
        
        // For correlation analysis
        public Dictionary<string, double> Correlations { get; set; } = new Dictionary<string, double>();
        
        public void CalculateStatistics()
        {
            if (!TimeSeries.Any()) return;
            
            Mean = TimeSeries.Average();
            Variance = TimeSeries.Select(v => Math.Pow(v - Mean, 2)).Average();
            StdDev = Math.Sqrt(Variance);
            Minimum = TimeSeries.Min();
            Maximum = TimeSeries.Max();
            Range = Maximum - Minimum;
            UniqueValues = TimeSeries.Distinct().Count();
        }
        
        public bool IsBoolean()
        {
            return UniqueValues <= 2;
        }
        
        public bool IsEnum()
        {
            return UniqueValues > 2 && UniqueValues <= 10;
        }
        
        public bool IsContinuous()
        {
            return UniqueValues > 10 && Range > 10;
        }
        
        public void AutoDetermineType()
        {
            if (IsBoolean())
            {
                SignalType = Core.Models.SignalType.Boolean;
                Unit = "bool";
            }
            else if (IsEnum())
            {
                SignalType = Core.Models.SignalType.Enum;
                Unit = "enum";
            }
            else if (IsContinuous())
            {
                SignalType = Core.Models.SignalType.Integer;
                
                // Auto-determine unit based on statistical properties
                if (Range < 100)
                    Unit = "%";
                else if (Range < 1000)
                    Unit = "RPM";
                else if (Range < 10000)
                    Unit = "speed";
                else
                    Unit = "raw";
            }
            else
            {
                SignalType = Core.Models.SignalType.Unknown;
                Unit = "raw";
            }
        }
        
        public override string ToString()
        {
            return $"{Name} ({ArbIDName}:Byte{ByteIndex}) [{SignalType}] {Minimum:F2}-{Maximum:F2} {Unit}";
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////

J1979Parameter.cs////////////////////////////////////////////////////////////////////////////
namespace CANalyzer.ReverseEngineering.Models
{
    /// <summary>
    /// SAE J1979 standard parameters for OBD-II
    /// </summary>
    public class J1979Parameter
    {
        public uint ID { get; set; }
        public string Name { get; set; } = string.Empty;
        public string Description { get; set; } = string.Empty;
        public string Unit { get; set; } = string.Empty;
        public double ScalingFactor { get; set; } = 1.0;
        public double Offset { get; set; } = 0.0;
        public int BytePosition { get; set; }
        public int Length { get; set; } = 1; // Usually 1-2 bytes
        
        // Common J1979 PIDs
        public static readonly Dictionary<uint, J1979Parameter> StandardParameters = new()
        {
            // Mode 01 PIDs
            { 0x201, new J1979Parameter { ID = 0x201, Name = "EngineRPM", Description = "Engine RPM", Unit = "RPM", ScalingFactor = 0.25, Offset = 0.0, BytePosition = 0, Length = 2 } },
            { 0x203, new J1979Parameter { ID = 0x203, Name = "VehicleSpeed", Description = "Vehicle Speed", Unit = "km/h", ScalingFactor = 1.0, Offset = 0.0, BytePosition = 0, Length = 1 } },
            { 0x205, new J1979Parameter { ID = 0x205, Name = "EngineCoolantTemp", Description = "Engine Coolant Temperature", Unit = "°C", ScalingFactor = 1.0, Offset = -40.0, BytePosition = 0, Length = 1 } },
            { 0x20B, new J1979Parameter { ID = 0x20B, Name = "IntakeManifoldPressure", Description = "Intake Manifold Pressure", Unit = "kPa", ScalingFactor = 1.0, Offset = 0.0, BytePosition = 0, Length = 1 } },
            { 0x20C, new J1979Parameter { ID = 0x20C, Name = "EngineLoad", Description = "Engine Load", Unit = "%", ScalingFactor = 100.0/255.0, Offset = 0.0, BytePosition = 0, Length = 1 } },
            { 0x210, new J1979Parameter { ID = 0x210, Name = "MAFAirFlowRate", Description = "MAF Air Flow Rate", Unit = "g/s", ScalingFactor = 0.01, Offset = 0.0, BytePosition = 0, Length = 2 } },
            
            // Mode 09 PIDs
            { 0x901, new J1979Parameter { ID = 0x901, Name = "VIN", Description = "Vehicle Identification Number", Unit = "string", BytePosition = 0, Length = 17 } },
            { 0x902, new J1979Parameter { ID = 0x902, Name = "CalibrationID", Description = "Calibration ID", Unit = "string", BytePosition = 0, Length = 16 } },
        };
        
        public static bool IsJ1979ID(uint id)
        {
            // J1979 IDs typically in ranges: 0x7E0-0x7EF (transmission), 0x7E8-0x7EF (reception)
            return (id >= 0x7E0 && id <= 0x7EF) || StandardParameters.ContainsKey(id);
        }
        
        public static J1979Parameter? GetParameter(uint id)
        {
            return StandardParameters.TryGetValue(id, out var param) ? param : null;
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////

CANPreprocessor.cs///////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.IO;
using System.Linq;
using CANalyzer.Core.Models;
using CANalyzer.Core.Parsers;
using CANalyzer.ReverseEngineering.Models;

namespace CANalyzer.ReverseEngineering.Analyzers
{
    /// <summary>
    /// Pre-processes CAN log files and converts them to runtime data structures
    /// Based on PreProcessor.py from CAN_Reverse_Engineering pipeline
    /// </summary>
    public class CANPreProcessor
    {
        public Dictionary<uint, ArbID> ArbIDDictionary { get; private set; } = new Dictionary<uint, ArbID>();
        public DataTable CANDataFrame { get; private set; } = new DataTable();
        public List<J1979Parameter> J1979Parameters { get; private set; } = new List<J1979Parameter>();
        public int TotalMessages { get; private set; }
        public double TimeSpan { get; private set; }
        
        public void ProcessLogFile(string filePath, LogFormat format)
        {
            Console.WriteLine($"Pre-processing {filePath} in {format} format...");
            
            // Clear previous data
            ArbIDDictionary.Clear();
            CANDataFrame = new DataTable();
            J1979Parameters.Clear();
            
            // Load messages using existing parser
            var messages = LogParser.Parse(filePath, format);
            TotalMessages = messages.Count;
            
            if (TotalMessages == 0)
            {
                Console.WriteLine("No messages found in log file");
                return;
            }
            
            Console.WriteLine($"Loaded {TotalMessages} messages");
            
            // Create DataFrame structure
            InitializeDataFrame();
            
            // Process each message
            int processedCount = 0;
            foreach (var message in messages)
            {
                ProcessMessage(message);
                processedCount++;
                
                if (processedCount % 1000 == 0)
                {
                    Console.WriteLine($"Processed {processedCount}/{TotalMessages} messages...");
                }
            }
            
            // Calculate time span
            if (messages.Count > 0)
            {
                TimeSpan = messages.Last().Timestamp - messages.First().Timestamp;
            }
            
            // Identify J1979 standard parameters
            IdentifyJ1979Parameters();
            
            Console.WriteLine($"Pre-processing complete: {ArbIDDictionary.Count} unique ArbIDs, {J1979Parameters.Count} J1979 parameters");
        }
        
        private void InitializeDataFrame()
        {
            CANDataFrame.Columns.Add("Timestamp", typeof(double));
            CANDataFrame.Columns.Add("ArbID", typeof(string));
            CANDataFrame.Columns.Add("DLC", typeof(int));
            
            // Add byte columns (up to 8 bytes for standard CAN)
            for (int i = 0; i < 8; i++)
            {
                CANDataFrame.Columns.Add($"Byte_{i}", typeof(byte));
            }
        }
        
        private void ProcessMessage(CANMessage message)
        {
            // Add to DataFrame
            DataRow row = CANDataFrame.NewRow();
            row["Timestamp"] = message.Timestamp;
            row["ArbID"] = $"0x{message.ID:X}";
            row["DLC"] = message.DLC;
            
            for (int i = 0; i < Math.Min(message.Data.Length, 8); i++)
            {
                row[$"Byte_{i}"] = message.Data[i];
            }
            
            // Fill remaining bytes with 0
            for (int i = Math.Min(message.Data.Length, 8); i < 8; i++)
            {
                row[$"Byte_{i}"] = (byte)0;
            }
            
            CANDataFrame.Rows.Add(row);
            
            // Add to ArbID dictionary
            if (!ArbIDDictionary.ContainsKey(message.ID))
            {
                ArbIDDictionary[message.ID] = new ArbID(message.ID);
            }
            
            ArbIDDictionary[message.ID].AddDataSample(message.Timestamp, message.Data);
        }
        
        private void IdentifyJ1979Parameters()
        {
            Console.WriteLine("Identifying J1979 standard parameters...");
            
            foreach (var arbId in ArbIDDictionary.Values)
            {
                if (J1979Parameter.IsJ1979ID(arbId.ID))
                {
                    arbId.IsJ1979Standard = true;
                    
                    var j1979Param = J1979Parameter.GetParameter(arbId.ID);
                    if (j1979Param != null)
                    {
                        arbId.J1979Parameter = j1979Param.Name;
                        arbId.J1979Description = j1979Param.Description;
                        J1979Parameters.Add(j1979Param);
                        
                        Console.WriteLine($"  Found J1979: {arbId.ID:X} = {j1979Param.Name} ({j1979Param.Description})");
                    }
                }
            }
        }
        
        public ArbID? GetArbID(uint id)
        {
            return ArbIDDictionary.TryGetValue(id, out var arbId) ? arbId : null;
        }
        
        public List<ArbID> GetMostFrequentArbIDs(int count = 20)
        {
            return ArbIDDictionary.Values
                .OrderByDescending(a => a.MessageCount)
                .Take(count)
                .ToList();
        }
        
        public DataTable GetArbIDTimeSeries(uint id, int byteIndex)
        {
            var table = new DataTable();
            table.Columns.Add("Timestamp", typeof(double));
            table.Columns.Add($"Byte_{byteIndex}", typeof(byte));
            
            var arbId = GetArbID(id);
            if (arbId == null || byteIndex >= arbId.DLC)
                return table;
            
            foreach (DataRow row in arbId.TimeSeriesData.Rows)
            {
                DataRow newRow = table.NewRow();
                newRow["Timestamp"] = row["Timestamp"];
                newRow[$"Byte_{byteIndex}"] = row[$"Byte_{byteIndex}"];
                table.Rows.Add(newRow);
            }
            
            return table;
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////

CANLexicalAnalyzers.cs///////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.Linq;
using CANalyzer.ReverseEngineering.Models;

namespace CANalyzer.ReverseEngineering.Analyzers
{
    /// <summary>
    /// Performs lexical analysis to detect signals in CAN data
    /// Based on LexicalAnalysis.py from CAN_Reverse_Engineering pipeline
    /// </summary>
    public class CANLexicalAnalyzer
    {
        public Dictionary<string, Signal> DetectedSignals { get; private set; } = new Dictionary<string, Signal>();
        public List<Signal> SignalList { get; private set; } = new List<Signal>();
        
        public void Analyze(Dictionary<uint, ArbID> arbIDDictionary, int minSamples = 10)
        {
            Console.WriteLine("Starting lexical analysis...");
            DetectedSignals.Clear();
            SignalList.Clear();
            
            // Analyze each ArbID
            foreach (var arbId in arbIDDictionary.Values)
            {
                if (arbId.MessageCount < minSamples)
                {
                    Console.WriteLine($"  Skipping {arbId.Name} (only {arbId.MessageCount} samples)");
                    continue;
                }
                
                Console.WriteLine($"  Analyzing {arbId.Name} ({arbId.MessageCount} samples, DLC: {arbId.DLC})");
                
                // Analyze each byte position
                for (int byteIndex = 0; byteIndex < arbId.DLC; byteIndex++)
                {
                    AnalyzeBytePosition(arbId, byteIndex);
                }
                
                // Analyze multi-byte signals (2-4 bytes)
                for (int startByte = 0; startByte < arbId.DLC - 1; startByte++)
                {
                    for (int byteLength = 2; byteLength <= 4 && startByte + byteLength <= arbId.DLC; byteLength++)
                    {
                        AnalyzeMultiByteSignal(arbId, startByte, byteLength);
                    }
                }
            }
            
            Console.WriteLine($"Lexical analysis complete: {DetectedSignals.Count} signals detected");
            
            // Calculate statistics for each signal
            foreach (var signal in SignalList)
            {
                signal.CalculateStatistics();
                signal.AutoDetermineType();
            }
        }
        
        private void AnalyzeBytePosition(ArbID arbId, int byteIndex)
        {
            var byteData = arbId.GetByteTimeSeries(byteIndex);
            if (byteData.Length < 10) return;
            
            // Calculate basic statistics
            var values = byteData.Select(b => (double)b).ToArray();
            double mean = values.Average();
            double variance = values.Select(v => Math.Pow(v - mean, 2)).Average();
            double stdDev = Math.Sqrt(variance);
            double min = values.Min();
            double max = values.Max();
            int uniqueValues = values.Distinct().Count();
            
            // Check if this byte contains meaningful data
            if (uniqueValues < 2 || (max - min) < 2)
            {
                // Static or nearly static data - not a signal
                return;
            }
            
            // Create signal
            string signalName = $"{arbId.Name}_Byte{byteIndex}";
            var signal = new Signal
            {
                Name = signalName,
                ArbIDName = arbId.Name,
                ArbID = arbId.ID,
                ByteIndex = byteIndex,
                StartBit = byteIndex * 8,
                Length = 8,
                TimeSeries = values.ToList(),
                Timestamps = arbId.GetTimestampSeries().ToList(),
                RawBytes = values,
                Mean = mean,
                StdDev = stdDev,
                Variance = variance,
                Minimum = min,
                Maximum = max,
                UniqueValues = uniqueValues
            };
            
            DetectedSignals[signalName] = signal;
            SignalList.Add(signal);
            
            Console.WriteLine($"    Detected signal: {signalName} ({uniqueValues} unique values, range: {min}-{max})");
        }
        
        private void AnalyzeMultiByteSignal(ArbID arbId, int startByte, int byteLength)
        {
            // Extract multi-byte values (little-endian)
            var timestamps = arbId.GetTimestampSeries();
            if (timestamps.Length < 10) return;
            
            List<double> multiByteValues = new List<double>();
            
            for (int i = 0; i < timestamps.Length; i++)
            {
                uint value = 0;
                for (int j = 0; j < byteLength; j++)
                {
                    if (startByte + j < arbId.DLC)
                    {
                        byte byteValue = arbId.GetByteTimeSeries(startByte + j)[i];
                        value |= (uint)(byteValue << (j * 8));
                    }
                }
                multiByteValues.Add(value);
            }
            
            // Calculate statistics
            var values = multiByteValues.ToArray();
            double mean = values.Average();
            double variance = values.Select(v => Math.Pow(v - mean, 2)).Average();
            double stdDev = Math.Sqrt(variance);
            double min = values.Min();
            double max = values.Max();
            int uniqueValues = values.Distinct().Count();
            
            // Check if meaningful
            if (uniqueValues < 5 || (max - min) < 10)
                return;
            
            // Check for monotonic patterns
            bool increasing = true;
            bool decreasing = true;
            for (int i = 1; i < values.Length; i++)
            {
                if (values[i] <= values[i - 1]) increasing = false;
                if (values[i] >= values[i - 1]) decreasing = false;
            }
            
            // Only keep if shows clear pattern
            if (!increasing && !decreasing && uniqueValues < values.Length / 2)
                return;
            
            string signalName = $"{arbId.Name}_Bytes{startByte}-{startByte + byteLength - 1}";
            var signal = new Signal
            {
                Name = signalName,
                ArbIDName = arbId.Name,
                ArbID = arbId.ID,
                ByteIndex = startByte,
                StartBit = startByte * 8,
                Length = byteLength * 8,
                TimeSeries = values.ToList(),
                Timestamps = timestamps.ToList(),
                RawBytes = values,
                Mean = mean,
                StdDev = stdDev,
                Variance = variance,
                Minimum = min,
                Maximum = max,
                UniqueValues = uniqueValues
            };
            
            DetectedSignals[signalName] = signal;
            SignalList.Add(signal);
            
            Console.WriteLine($"    Detected multi-byte signal: {signalName} ({byteLength} bytes, {uniqueValues} unique values)");
        }
        
        public List<Signal> GetSignalsByArbID(uint arbId)
        {
            return SignalList.Where(s => s.ArbID == arbId).ToList();
        }
        
        public List<Signal> GetBooleanSignals()
        {
            return SignalList.Where(s => s.IsBoolean()).ToList();
        }
        
        public List<Signal> GetEnumSignals()
        {
            return SignalList.Where(s => s.IsEnum()).ToList();
        }
        
        public List<Signal> GetContinuousSignals()
        {
            return SignalList.Where(s => s.IsContinuous()).ToList();
        }
        
        public Signal? GetSignal(string name)
        {
            return DetectedSignals.TryGetValue(name, out var signal) ? signal : null;
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////

CANSemanticAnalyzers.cs//////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using MathNet.Numerics.Statistics;
using CANalyzer.ReverseEngineering.Models;

namespace CANalyzer.ReverseEngineering.Analyzers
{
    /// <summary>
    /// Represents a cluster dendrogram node
    /// </summary>
    public class ClusterDendrogram
    {
        public int ClusterId { get; set; }
        public List<int> Members { get; set; } = new List<int>();
        public double Distance { get; set; }
        public int Level { get; set; }
    }

    /// <summary>
    /// Performs semantic analysis including correlation and clustering
    /// Based on SemanticAnalysis.py from CAN_Reverse_Engineering pipeline
    /// </summary>
    public class CANSemanticAnalyzer
    {
        public DataTable CorrelationMatrix { get; private set; } = new DataTable();
        public Dictionary<int, List<Signal>> Clusters { get; private set; } = new Dictionary<int, List<Signal>>();
        public Dictionary<string, int> SignalClusterMap { get; private set; } = new Dictionary<string, int>();
        public List<ClusterDendrogram> DendrogramData { get; private set; } = new List<ClusterDendrogram>();
        
        private const double CorrelationThreshold = 0.7;
        private const int MaxClusters = 10;
        
        public void Analyze(List<Signal> signals, int minClusterSize = 3)
        {
            Console.WriteLine("Starting semantic analysis...");
            
            if (signals.Count < 2)
            {
                Console.WriteLine("Not enough signals for semantic analysis");
                return;
            }
            
            // Build correlation matrix
            BuildCorrelationMatrix(signals);
            
            // Perform hierarchical clustering
            PerformHierarchicalClustering(signals);
            
            // Create clusters
            CreateClusters(signals, minClusterSize);
            
            Console.WriteLine($"Semantic analysis complete: {Clusters.Count} clusters found");
        }
        
        private void BuildCorrelationMatrix(List<Signal> signals)
        {
            Console.WriteLine("Building correlation matrix...");
            
            CorrelationMatrix = new DataTable();
            CorrelationMatrix.Columns.Add("Signal", typeof(string));
            
            // Add columns for each signal
            foreach (var signal in signals)
            {
                CorrelationMatrix.Columns.Add(signal.Name, typeof(double));
            }
            
            // Calculate pairwise correlations
            for (int i = 0; i < signals.Count; i++)
            {
                DataRow row = CorrelationMatrix.NewRow();
                row["Signal"] = signals[i].Name;
                
                for (int j = 0; j < signals.Count; j++)
                {
                    double correlation = CalculateCorrelation(signals[i], signals[j]);
                    row[signals[j].Name] = correlation;
                    
                    // Store in signal's correlation dictionary
                    signals[i].Correlations[signals[j].Name] = correlation;
                }
                
                CorrelationMatrix.Rows.Add(row);
            }
        }
        
        private double CalculateCorrelation(Signal signalA, Signal signalB)
        {
            if (signalA == signalB)
                return 1.0;
            
            if (signalA.TimeSeries.Count != signalB.TimeSeries.Count || signalA.TimeSeries.Count < 10)
                return 0.0;
            
            try
            {
                // Align time series
                var alignedA = signalA.TimeSeries.ToArray();
                var alignedB = signalB.TimeSeries.ToArray();
                
                // Calculate Pearson correlation
                return Correlation.Pearson(alignedA, alignedB);
            }
            catch (Exception)
            {
                return 0.0;
            }
        }
        
        private void PerformHierarchicalClustering(List<Signal> signals)
        {
            Console.WriteLine("Performing hierarchical clustering...");
            
            if (signals.Count < 2) return;
            
            // Create distance matrix
            int n = signals.Count;
            double[,] distanceMatrix = new double[n, n];
            
            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    if (i == j)
                    {
                        distanceMatrix[i, j] = 0.0;
                    }
                    else
                    {
                        double correlation = signals[i].Correlations[signals[j].Name];
                        distanceMatrix[i, j] = 1.0 - Math.Abs(correlation); // Convert to distance
                    }
                }
            }
            
            // Simple hierarchical clustering (single linkage)
            var clusters = new List<List<int>>();
            for (int i = 0; i < n; i++)
            {
                clusters.Add(new List<int> { i });
            }
            
            DendrogramData.Clear();
            
            while (clusters.Count > 1)
            {
                // Find closest clusters
                double minDistance = double.MaxValue;
                int clusterA = -1, clusterB = -1;
                
                for (int i = 0; i < clusters.Count; i++)
                {
                    for (int j = i + 1; j < clusters.Count; j++)
                    {
                        double distance = CalculateClusterDistance(clusters[i], clusters[j], distanceMatrix);
                        if (distance < minDistance)
                        {
                            minDistance = distance;
                            clusterA = i;
                            clusterB = j;
                        }
                    }
                }
                
                if (clusterA == -1 || clusterB == -1) break;
                
                // Merge clusters
                var newCluster = new List<int>(clusters[clusterA]);
                newCluster.AddRange(clusters[clusterB]);
                
                // Record dendrogram data
                DendrogramData.Add(new ClusterDendrogram
                {
                    ClusterId = DendrogramData.Count,
                    Members = new List<int>(newCluster),
                    Distance = minDistance,
                    Level = clusters.Count
                });
                
                // Replace clusterA with merged cluster
                clusters[clusterA] = newCluster;
                
                // Remove clusterB
                clusters.RemoveAt(clusterB);
            }
        }
        
        private double CalculateClusterDistance(List<int> clusterA, List<int> clusterB, double[,] distanceMatrix)
        {
            // Single linkage (minimum distance)
            double minDistance = double.MaxValue;
            
            foreach (int a in clusterA)
            {
                foreach (int b in clusterB)
                {
                    double distance = distanceMatrix[a, b];
                    if (distance < minDistance)
                        minDistance = distance;
                }
            }
            
            return minDistance;
        }
        
        private void CreateClusters(List<Signal> signals, int minClusterSize)
        {
            Console.WriteLine("Creating clusters from dendrogram...");
            
            Clusters.Clear();
            SignalClusterMap.Clear();
            
            if (DendrogramData.Count == 0)
            {
                // Create one cluster per signal
                for (int i = 0; i < signals.Count; i++)
                {
                    Clusters[i] = new List<Signal> { signals[i] };
                    SignalClusterMap[signals[i].Name] = i;
                }
                return;
            }
            
            // Determine optimal clusters based on distance threshold
            double maxDistance = DendrogramData.Max(d => d.Distance);
            double threshold = maxDistance * 0.3; // 30% of max distance
            
            // Find clusters at threshold level
            var clustersAtThreshold = new List<List<int>>();
            var assignedSignals = new HashSet<int>();
            
            // Start from largest distance and work backwards
            var sortedDendrogram = DendrogramData.OrderByDescending(d => d.Distance).ToList();
            
            foreach (var dendrogram in sortedDendrogram)
            {
                if (dendrogram.Distance > threshold)
                {
                    // This is a valid cluster at threshold
                    bool alreadyAssigned = false;
                    foreach (int member in dendrogram.Members)
                    {
                        if (assignedSignals.Contains(member))
                        {
                            alreadyAssigned = true;
                            break;
                        }
                    }
                    
                    if (!alreadyAssigned && dendrogram.Members.Count >= minClusterSize)
                    {
                        clustersAtThreshold.Add(new List<int>(dendrogram.Members));
                        foreach (int member in dendrogram.Members)
                        {
                            assignedSignals.Add(member);
                        }
                    }
                }
            }
            
            // Add unassigned signals to their own clusters
            for (int i = 0; i < signals.Count; i++)
            {
                if (!assignedSignals.Contains(i))
                {
                    clustersAtThreshold.Add(new List<int> { i });
                }
            }
            
            // Create final clusters
            int clusterId = 0;
            foreach (var clusterIndices in clustersAtThreshold)
            {
                if (clusterIndices.Count == 0) continue;
                
                var clusterSignals = new List<Signal>();
                foreach (int index in clusterIndices)
                {
                    if (index < signals.Count)
                    {
                        var signal = signals[index];
                        clusterSignals.Add(signal);
                        SignalClusterMap[signal.Name] = clusterId;
                        
                        // Update signal cluster info
                        signal.ClusterId = clusterId;
                        signal.ClusterLabel = $"Cluster_{clusterId}";
                    }
                }
                
                Clusters[clusterId] = clusterSignals;
                clusterId++;
            }
            
            // Label clusters based on signal types
            foreach (var kvp in Clusters)
            {
                var cluster = kvp.Value;
                if (cluster.Count > 0)
                {
                    // Count signal types in cluster
                    var typeCounts = new Dictionary<Core.Models.SignalType, int>();
                    foreach (var signal in cluster)
                    {
                        if (!typeCounts.ContainsKey(signal.SignalType))
                            typeCounts[signal.SignalType] = 0;
                        typeCounts[signal.SignalType]++;
                    }
                    
                    // Determine dominant type
                    var dominantType = typeCounts.OrderByDescending(t => t.Value).FirstOrDefault();
                    Console.WriteLine($"  Cluster {kvp.Key}: {cluster.Count} signals, dominant type: {dominantType.Key}");
                }
            }
        }
        
        public List<Signal> GetSignalsInCluster(int clusterId)
        {
            return Clusters.TryGetValue(clusterId, out var signals) ? signals : new List<Signal>();
        }
        
        public List<Signal> GetStronglyCorrelatedSignals(string signalName, double threshold = 0.8)
        {
            var result = new List<Signal>();
            
            var signal = SignalList.FirstOrDefault(s => s.Name == signalName);
            if (signal == null) return result;
            
            foreach (var correlation in signal.Correlations)
            {
                if (Math.Abs(correlation.Value) > threshold && correlation.Key != signalName)
                {
                    var correlatedSignal = SignalList.FirstOrDefault(s => s.Name == correlation.Key);
                    if (correlatedSignal != null)
                        result.Add(correlatedSignal);
                }
            }
            
            return result;
        }
        
        // Helper property for external access
        public List<Signal> SignalList { get; private set; } = new List<Signal>();
        
        public void SetSignals(List<Signal> signals)
        {
            SignalList = signals;
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////

HierarchicalClustering.cs////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.Linq;

namespace CANalyzer.ReverseEngineering.Utils
{
    /// <summary>
    /// Implementation of hierarchical clustering algorithm
    /// </summary>
    public static class HierarchicalClustering
    {
        public class ClusterNode
        {
            public int Id { get; set; }
            public List<int> Members { get; set; } = new List<int>();
            public double Distance { get; set; }
            public ClusterNode? Left { get; set; }
            public ClusterNode? Right { get; set; }
            public int Height { get; set; }
        }

        public static List<ClusterNode> Cluster(double[,] distanceMatrix, string linkage = "single")
        {
            int n = distanceMatrix.GetLength(0);
            
            // Initialize clusters: each point is its own cluster
            var clusters = new List<ClusterNode>();
            for (int i = 0; i < n; i++)
            {
                clusters.Add(new ClusterNode
                {
                    Id = i,
                    Members = new List<int> { i },
                    Height = 0
                });
            }

            var dendrogram = new List<ClusterNode>();

            while (clusters.Count > 1)
            {
                // Find the two closest clusters
                double minDistance = double.MaxValue;
                int clusterA = -1, clusterB = -1;

                for (int i = 0; i < clusters.Count; i++)
                {
                    for (int j = i + 1; j < clusters.Count; j++)
                    {
                        double distance = GetClusterDistance(
                            clusters[i], clusters[j], distanceMatrix, linkage);
                        
                        if (distance < minDistance)
                        {
                            minDistance = distance;
                            clusterA = i;
                            clusterB = j;
                        }
                    }
                }

                if (clusterA == -1 || clusterB == -1)
                    break;

                // Merge the two clusters
                var newCluster = new ClusterNode
                {
                    Id = n + dendrogram.Count,
                    Members = new List<int>(clusters[clusterA].Members),
                    Distance = minDistance,
                    Left = clusters[clusterA],
                    Right = clusters[clusterB],
                    Height = Math.Max(clusters[clusterA].Height, clusters[clusterB].Height) + 1
                };
                
                newCluster.Members.AddRange(clusters[clusterB].Members);

                // Add to dendrogram
                dendrogram.Add(newCluster);

                // Update cluster list
                clusters.RemoveAt(Math.Max(clusterA, clusterB));
                clusters.RemoveAt(Math.Min(clusterA, clusterB));
                clusters.Add(newCluster);
            }

            return dendrogram;
        }

        private static double GetClusterDistance(
            ClusterNode clusterA, ClusterNode clusterB, 
            double[,] distanceMatrix, string linkage)
        {
            return linkage.ToLower() switch
            {
                "single" => GetSingleLinkageDistance(clusterA, clusterB, distanceMatrix),
                "complete" => GetCompleteLinkageDistance(clusterA, clusterB, distanceMatrix),
                "average" => GetAverageLinkageDistance(clusterA, clusterB, distanceMatrix),
                _ => GetSingleLinkageDistance(clusterA, clusterB, distanceMatrix)
            };
        }

        private static double GetSingleLinkageDistance(
            ClusterNode clusterA, ClusterNode clusterB, double[,] distanceMatrix)
        {
            double minDistance = double.MaxValue;
            
            foreach (int a in clusterA.Members)
            {
                foreach (int b in clusterB.Members)
                {
                    double distance = distanceMatrix[a, b];
                    if (distance < minDistance)
                        minDistance = distance;
                }
            }
            
            return minDistance;
        }

        private static double GetCompleteLinkageDistance(
            ClusterNode clusterA, ClusterNode clusterB, double[,] distanceMatrix)
        {
            double maxDistance = double.MinValue;
            
            foreach (int a in clusterA.Members)
            {
                foreach (int b in clusterB.Members)
                {
                    double distance = distanceMatrix[a, b];
                    if (distance > maxDistance)
                        maxDistance = distance;
                }
            }
            
            return maxDistance;
        }

        private static double GetAverageLinkageDistance(
            ClusterNode clusterA, ClusterNode clusterB, double[,] distanceMatrix)
        {
            double totalDistance = 0;
            int count = 0;
            
            foreach (int a in clusterA.Members)
            {
                foreach (int b in clusterB.Members)
                {
                    totalDistance += distanceMatrix[a, b];
                    count++;
                }
            }
            
            return count > 0 ? totalDistance / count : 0;
        }

        public static List<List<int>> CutDendrogram(List<ClusterNode> dendrogram, int numClusters)
        {
            var result = new List<List<int>>();
            
            if (numClusters <= 0 || dendrogram.Count == 0)
                return result;

            // Sort dendrogram by distance in descending order
            var sortedDendrogram = dendrogram.OrderByDescending(d => d.Distance).ToList();

            // Take the top (numClusters - 1) merges
            var clusters = new Dictionary<int, List<int>>();
            var clusterMap = new Dictionary<int, int>();
            int nextClusterId = 0;

            // Process dendrogram
            for (int i = 0; i < sortedDendrogram.Count; i++)
            {
                var node = sortedDendrogram[i];
                
                if (i < numClusters - 1)
                {
                    // This merge becomes a cluster
                    var clusterMembers = new List<int>(node.Members);
                    clusters[nextClusterId] = clusterMembers;
                    
                    foreach (int member in clusterMembers)
                    {
                        clusterMap[member] = nextClusterId;
                    }
                    
                    nextClusterId++;
                }
                else
                {
                    // Assign members to existing clusters
                    foreach (int member in node.Members)
                    {
                        if (!clusterMap.ContainsKey(member))
                        {
                            // Create new cluster for unassigned member
                            clusters[nextClusterId] = new List<int> { member };
                            clusterMap[member] = nextClusterId;
                            nextClusterId++;
                        }
                    }
                }
            }

            // Handle any unassigned members
            int maxMemberId = 0;
            foreach (var node in sortedDendrogram)
            {
                maxMemberId = Math.Max(maxMemberId, node.Members.Max());
            }

            for (int i = 0; i <= maxMemberId; i++)
            {
                if (!clusterMap.ContainsKey(i))
                {
                    clusters[nextClusterId] = new List<int> { i };
                    clusterMap[i] = nextClusterId;
                    nextClusterId++;
                }
            }

            return clusters.Values.ToList();
        }

        public static List<List<int>> CutDendrogramByDistance(List<ClusterNode> dendrogram, double distanceThreshold)
        {
            var result = new List<List<int>>();
            
            if (dendrogram.Count == 0)
                return result;

            // Sort dendrogram by distance in descending order
            var sortedDendrogram = dendrogram.OrderByDescending(d => d.Distance).ToList();

            var clusters = new Dictionary<int, List<int>>();
            var clusterMap = new Dictionary<int, int>();
            int nextClusterId = 0;

            // Process dendrogram
            foreach (var node in sortedDendrogram)
            {
                if (node.Distance > distanceThreshold)
                {
                    // This merge is above threshold, create cluster
                    bool anyAssigned = false;
                    foreach (int member in node.Members)
                    {
                        if (clusterMap.ContainsKey(member))
                        {
                            anyAssigned = true;
                            break;
                        }
                    }
                    
                    if (!anyAssigned)
                    {
                        clusters[nextClusterId] = new List<int>(node.Members);
                        foreach (int member in node.Members)
                        {
                            clusterMap[member] = nextClusterId;
                        }
                        nextClusterId++;
                    }
                }
            }

            // Handle any unassigned members
            int maxMemberId = 0;
            foreach (var node in sortedDendrogram)
            {
                maxMemberId = Math.Max(maxMemberId, node.Members.Max());
            }

            for (int i = 0; i <= maxMemberId; i++)
            {
                if (!clusterMap.ContainsKey(i))
                {
                    clusters[nextClusterId] = new List<int> { i };
                    clusterMap[i] = nextClusterId;
                    nextClusterId++;
                }
            }

            return clusters.Values.ToList();
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////





Не упрощай код! Не меняй структуру! Весь исходный код тебе предоставлен! Проанализируй, прежде чем менять!
Измененный код предоставляй целиком в файле! Без сокращений и заглушек!